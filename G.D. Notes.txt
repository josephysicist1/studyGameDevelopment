
- Unity yüklerken WebGl Build Support modülünü de yükle, yaratacağın oyunun böylece web'de de oynanmasını 
sağlayabilirsin

- Unity ne işe yarar: Visual interface for creating games and systems of existing code we can use(physics,
rendering, audio)

- Unity ve VS Code'u .cs file ile birbirine bağlıyoruz. .cs dosyaları bizim vscodeda yazacağımız
script dosyaları. 

- Buradaki kodlar game engine'a ne yapılacağını söylüyor.

- Proje oluştururken unity hub içinden project->new Project oluşturuyoruz, burada Universal 3D'yi seçeceğiz. Mobil
ya da oyunun HD versiyonu için de burada seçenekler mevcut

- İlk Projeyi oluşturduktan sonra unity açılacak ve solda sample scene altında 3 tane game object çıkacak
Bunlar: main camera, directional light ve global volume

- Bu objectlerde componentler var, bunlar, ekranın sağındaki inspector altında. Her objectde olan componentlerden biri de "Transform" component, bu component bize
positionı set etmeye, rotation varsa uygulamada işimize yarayacak.

- Buradaki 3 game object'e ek olarak kendi game objectimizi nasıl yaratacağız. Oradaki boşluğa gelip sağ 
tıklayıp 3D object'den cube diyeceğiz.

- Mouse'un right click butonu ile object üzerinde kamerayı döndürerek işlem yapabiliyoruz, ve ok butonları 
ile de ekran üzerinde gidip gelebiliyoruz bunlarla point of view'u değiştirebiliyoruz.

- Object'den çıkan renkli oklar bize 3 boyutlu koordinat düzlemindeki x y z eksenlerini gösteriyor.

- Object oluşturmadan önce ekranda zaten bulunan küçük küp "global volume". Bunun "rendering" ile
alakası var ancak bu ilerleyen aşamalarda

- Object üzerinde çıkan koordinat düzlemini gösteren oklardan birinin üzerine mousela gelip basılı tutarsan
o eksende hareket ettirebilirsin

- Ekranın sağ tarafındaki "transform" kısmındaki koordinatları kullanarak da objeleri hareket ettirebilirsin

- Transform kısmında gösterilen position kısmını "W" tuşu, Rotation kısmını "E" tuşu ve Scale kısmını da
"R" tuşu kontrol ediyor. Bu şekilde istediğimiz pozisyonlarda object ile oynayabiliriz.

- R tuşuna basıp küp olan bir objeyi 3 eksende de çekip uzatabilir ya da kısaltabilirim.

- Araba'nın parçalarını ayrı ayrı object olarak ekliyoruz. Önce arabanın ana gövdesi için küp ekledik,
sonra arabanın tekerlekleri için de silindir ekledik. Bunlar solda Sample Scene içinde duruyorlar. Bu 
silindiri E tuşuna basıp rotate ettirerek yer düzlemine paralel hale getiriyoruz.

- Ekranın sol altında Assets kısmı var. Burada olan her şey bilgisayarın hard drive'ında tutuluyor.
Bizim Project directory'deki Assets kısmı ile hierarchy arasındaki en büyük fark bu. Hierarchy içinde
game objects var these are the game objects that are located and living within our sample scene and 
our sample scene is saved in the "Scenes" folder onto our hard drive.

- Simdi Assets içinde yeni bir material oluşturacağız ve adına da colour1 diyeceğiz. Colour1'a tıklayınca
sağ tarafta inspector içinde bu material'ın özellikleriyle biraz oynayacağız. Mesela burada "Base Map" denilen
yerde bu material'ın rengini ayarlıyoruz. Ayarlamayı bitirdikten sonra bu materialı sürekleyerek tasarım
yaptığımız ekrandaki objectlerden birinin üzerine bırakınca object direkt olarak renk değiştiriyor. 

- Silindir olan tekerleğin adını Wheel olarak değiştirdik sonra bunu duplicate ederek 4 tane yapıp
arabanın ana bodysi içine koordinat düzleminde oynatarak ekleyebiliyoruz.

- Sol tarafta objectleri birden fazla olacak şekilde seçip aynı oranda ekranda koordinat düzleminde
hareket ettirebilir ya da aynı oranda rotate ettirebilirsin.

- VSCode'a extension eklemeyi unutma. C#, Unity ve Unity Code Snippet'ı extensions kısmından ekle

- Unity açıldıktan sonra sol üstte Edit kısmı altındaki Preferences'a tıkladıktan sonra External Tools
altındaki External Script Editor'u VS Code olarak ayarla.

- Assets altında sağa tıklayıp create diyip sonra scripting ve C# Script'e basarak script dosyasını
Assets altında tanımlıyorsun.

- Bu script dosyasına çift tıklayınca VSCode açılacak.

- Game Design felsefesinde, Player Experience(akıllıca mı, panik mi,acele mi, dikkatli mi hissetmesini
istiyoruz.), Core Mechanic(Move & Dodge obstacles, burada oyunun ana temasının mekaniği üzerinde
duruyoruz),Game Loop(Get from A to B)

- Avoiding Obstacle(AO) projesinde önce 3D object plane yaratarak bayağı büyük bir scale a getirdik.
Sonra assets kısmına material ekledik, bunun "base map"'ine gelerek siyah yaptık ve ekrana doğru
sürükleyerek plane içine bıraktık, böylece plane siyah oldu.

- Plane'in parlaklığını yani güneş paneli gibi yansıyan siyah tarzından düz siyaha geçmesini
istersek o zaman sağ tarafta base map altında smoothness var, onu azaltman lazım.

- Assets altında folder yani directory oluşturup materiallerin hepsini oraya atabilirsin, böylece
oyun dosyalarını daha modüler hale getirebilirsin. Folder oluştururken de assets içindeki boşlukta 
sağa tıklayarak create diyip sonra folder diyeceksin, isimlendirip sonra şimdiye kadar oluşturduğun
color materiallerini içine atacaksın.

- Sonrasında da yine assets içinde Scripts isimli başka bir dizin oluşturacaksın. Buraya script
dosyalarını atacaksın.

- Script oluştururken önce MonoBehaviourScript oluşturduk bu file which is the standard
unity starting point script. Herhangi bir dosya oluştururken ismini yazmadan önce 
herhangi bir yere tıklarsan bir daha onu değiştiremezsin o yüzden önce ismini yaz.

- Oluşturdugumuz scripte "Mover" adını vererek bıraktık.

- Oluşturulan script dosyalarını bir object ile bağlamamız gerekiyor. O script dosyasında 
yazanlar o object'i kontrol edecek ve hareketlerini belirleyecek. Script dosyasını object ile 
bağlamak için script dosyasına basılı tutarak solda Sample Scene altındaki bağlamak istediğimiz
object'e sürüklüyoruz ya da object'e tıklayınca sağda açılan inspector altındaki "Add component" 
kısmına gelerek oradan script dosyasının adını aratıp oradan ekleyebiliyoruz.

- Sonrasında script dosyasına çift tıklayınca vscode açılacak.

- Unity'nin başlangıç noktası olan scriptinde start ve update metodları var. Unity'de 
start butonuna bastığımızda player'ın bütün componentleri aktif hale gelecek.

- 
void Start()
    {
        transform.Translate();
    }
burada yazdıgığımız transform, unity içinde object'e tıklayınca sağda gördüğümüz
Transform componentini temsil ediyor. Burada metodları kullanarak transform altındaki
position, rotation ya da scale değerlerini manipüle edebiliriz.

- Translate içinde hangi koordinat ekseninde ne kadar hızlı gitmek istediğini belirtiyorsun

- Yukarıda "Scene" yanında bir de yanında konsol işareti bulunan "Game" sekmesi var. Bu sekme
oyunun oynanacağı zaman kullanıcı gözünden nasıl görüleceğini gösteriyor. Onu da sürükleyerek
Scene'in sağ tarafına bırakıp hem geliştirdiğimiz şeyi hem de oyuncu tarafından görülen kısmını
aynı anda görüyoruz.

- Sol tarafta bulunan main camera objecti, kullanıcının player'a nereden bakacağını belirtmemizi
sağlıyor.

- Main camerayı da ayarladıktan sonra play butonuna tıklayınca 

void Start()
    {
        transform.Translate(1,0,0);
    }

kodu sayesinde player objecti x ekseninde 1 birim sağa gidiyor. Eğer stop
butonuna basarsan object başlangıç noktasına geri geliyor.

- Frame is every time our game calculates what should be happening in
our World.

- Buradaki kullanımda "frame", ekranın bir kez güncellenmesini ifade eder. Bilgisayar oyunlarında ya da gerçek zamanlı simülasyonlarda saniyede kaç kez ekranın yenilendiğini belirtmek için kullanılır.
FPS (Frames Per Second): Saniyede kaç frame işlendiğini gösterir. Örneğin 60 FPS, saniyede 60 kez ekranın yenilendiği anlamına gelir.

- Bir animasyonun içindeki her bir poz da "frame" olarak adlandırılır. Örneğin bir yürüyüş animasyonu 30 kareden oluşuyorsa, 
bu 30 frame’de karakterin adım adım hareketi gösterilir.

- Eğer bu satırı , transform.Translate(1,0,0) , update metodu içinde yazarsak
o zaman frame hesabı işin içine girecek. Saniyede 60 frame işliyorsa o zaman
bir saniye içerisinde yukarıdaki kod, objecti x ekseninde 60 birim ilerletecek.

- transform.Translate(0.01,0,0); yazarsan hata alırsın double'ı float'a çevirmen
gerekiyor bunun için de  transform.Translate(0.01f,0f,0f); yazman lazım.

- C# da integer bir data tanımlarken int hitPoint = 20; diyerek tanımlıyoruz, ya da
float tanımlamak istediğimizde float speed = 3.8f; 
Boolean tanımlamak istediğimizde bool isAlive = True; 
String tanımlamak istediğimizde string myName = "yusuf";

- Oyun içinde kullanacağımız değişkenleri tanımlayacağımız zaman start metodu üstünde ve
Public Class Mover : MonoBehavior altında tanımlıyoruz.

-
using UnityEngine;

public class Mover : MonoBehaviour
{
    float xValue = 0.01f;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        transform.Translate(xValue,0f,0f);
    }
}

- Object'ini hareket ettirmek istediğin koordinata unity arayüzündeki oklardan bakabilirsin.

- Bir değişiklik yapıp play butonuna her bastığımızda Sceneleri ve domainleri yüklüyor, bu da 
zaman kaybı. Statik değişkenlerle uğraştığımız durumlarda bunu yapmamıza gerek yok. Ancak ilerleyen
zamanlarda eger bir şeylerin ters gittiğini ya da hata aldığını görürsen o zaman tekrar eski haline
getirebilirsin. Edit altında Project settings kısmına geleceksin. Orada Editor'e tıklayıp
en alta ineceksin. "Enter Play Mode Settings" kısmının ayarlarını değiştireceksin. Do not reload domain 
or scene olanı seçeceksin.

- Start metodu üstünde tanımladığın değişkenleri [SerializeField] float yValue = 0.01f; bu şekilde
tanımlarsan o zaman bu değişkeni unity içinde görebiliyor ve değişkenin değerini unity içinde değiştirebiliyor
oluyorsun. Bu script dosyasını bağladığın object'in ekranın sağ tarafındaki inspectorda bu değişkeni 
görüyorsun. Sağ taraftaki Mover scriptinin altında "Y values" yazıyor. Bu sayede original script kodu içinde
herhangi bir değişiklik yapmadan sadece unity arayüzünde değişkenleri test edebiliyorsun. Buna da SerializingField
deniyor.

- SerializeField olarak tanımladığın değişkenleri unity içinde Mouse'unla üzerine basılı tutup sağa sola 
oynatarak da değerlerini değiştirebilirsin ancak koddaki değer değişmez. 

- Oyuna "Simple Movement" özelliği katabilmek için birçok yol var. Biri Input System, diğeri position
of object(bunu ya manuel olarak change location yapıyoruz ya da force uyguluyoruz. Force uyguladığın durumda unity'nin
fizik kısmını kullanıyoruz.)

- Unity 6 ile birlikte yeni bir input sistemi devreye aldılar ancak bu projede eski input sistemini 
kullanacağım. Edit->Project Settings->Solda Player'a tıkla ve sağdaki geniş kısımda Other Settings kısmını
expand et ve alta yakın bir yerde "Active Input Handling" denilen bir kısım var. Burayı "Input System Package Old"'a çek.

- Aynı şekilde Project Settings altında "Input Manager" kısmı var. Burada axislerle ilgili ayarlamaları yapabiliyoruz, yani
hangi tuşları hangi eksenlere assign edeceğimizi burada belirtiyoruz. Burada horizontal sağ ve sol u kastediyor. Alternative Negative 
Button derken solu, Alternative Positive Button derken de sağı kastediyor. Aynı şekilde vertical kısmında da tuşlar zaten tanımlanmış
durumda ancak değiştirmek istediğinde ayarlamaları buradan yapıyorsun.

- Update metodu içinde değişkenleri SerializeField olarak tanımlayamıyoruz çünkü zaten burada dynamic olarak kontrol ediyoruz değişkenleri.

- 
void Update()
    {
        float xValue = Input.GetAxis("Horizontal");
        float yValue = 0f;
        float zValue = 0f;
        transform.Translate(xValue,yValue,zValue);
    }

Burada x değerini keyborddan sağ ve sol ok tuşlarına basarak ayarlacağımız kodu yazdık. Burada string olarak belirttiğin
ifadeye dikkat et, eğer horizontal eksende ilerleteceksen aynen bu şekilde yazman lazım yoksa kodun çalışmaz. Bunu yazdıktan sonra
unity'de play butonuna bastıgında ok tuşlarıyla objectini horizontal eksende pozitif ve negatif yönde ilerletebiliyorsun.
Dikey eksende ilerletmek için de ikinci satırı float yValue = Input.GetAxis("Vertical"); şeklinde güncelliyorum.

- Buradan çıkan diğer sorun ok tuşlarını kullandıgımızda object çok hızlı bir şekilde hareket ediyor, bu hareket
hızını ayarlamamız gerekecek. Bunu da Time.deltatime kullanarak yapacagız.

- Unity'de Scene sekmesinin yanındaki Game içinde "Stat" adında bir sekme daha var. Oraya tıklarsan oyun esnasındaki FPS ve CPU ile
ilgili değerleri anlık olarak göreceksin. Burada ayarlamak istediğimi kısım frame rate. Burası bilgisayardan bilgisayara değişen
bir değer. Bunu consistent hale getirmek oyun ve oyuncular için önemli.

- Using Time.deltaTime Unity can tell us how long each frame took to execute

- When we multiply something by Time.deltaTime, it makes our game "frame rate independent" which means
the game behaves the same on fast and slow computers.

- Input.GetAxis("Horizontal") burası bize -1 ile 1 arasında değer döndürüyor.

- 
 void Update()
    {
        float xValue = Input.GetAxis("Horizontal") * Time.deltaTime;
        float yValue = Input.GetAxis("Vertical") * Time.deltaTime;
        float zValue = 0f;
        transform.Translate(xValue,yValue,zValue);
    }

artık frame rate independent hale getirdik. Eğer objectin bu halindeki hızı yavaş ya da yine de hızlı
bulduysan o zaman bir değer ile çarp. Örnek olarak
 float xValue = Input.GetAxis("Horizontal") * Time.deltaTime * 2;

-
using UnityEngine;

public class Mover : MonoBehaviour
{
    [SerializeField] int moveSpeed = 10;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        float xValue = Input.GetAxis("Horizontal") * Time.deltaTime * moveSpeed;
        float yValue = Input.GetAxis("Vertical") * Time.deltaTime * moveSpeed;
        float zValue = 0f;
        transform.Translate(xValue,yValue,zValue);
    }
}

- Player ya da yarattığımız object hareket ederken cameranın da onunla birlikte hareket etmesini
istiyorsak cinemachine'ı entegre edeceğiz.

- Cinemachine is a unity package. Birden fazla camerayı scene içinde kontrol edebilmemizi sağlıyor,
camera için kurallar koymamızı sağlıyor

- There is a few different aspects of cinemachine. First of all, we have a "cinemachine brain" which sits
right on top of our main camera. It figures out what the player should see and then we can have a number 
of virtual cameras that feed into the brain. Burada brain kararları veriyor, camera2 sıra sende, ya da 1. kamera
artık sendeyiz gibisinden. Ancak bu oyun özelinde sadece bir tane virtual camera kullanacağız yani kameralar 
arasında gidip gelmeyeceğiz.

- Önce package manager'dan cinemachine'ı yükleyeceğiz. Sonra virtual kamera ekleyeceğiz sonrasında da 
we will make sure Cinemachine Brain component has been added to Main Camera and point the virtual camera 
to follow the player and then tune distance, rotation, damping.

- Package Manager'a yukarıda "Window" kısmından erişiyorsun. Sekme açıldıktan sonra solda "Unity Registry"'e tıkla 
Burada ulaşabileceğin bütün packageları görüyorsun. Buradan Cinemachine'ı yükle.

- Paketin yüklenip yüklenmediğini kontrol etmek istiyorsan sol altta Project altında Packages kısmını genişlet 
ve alttaki paketlere bak

- Solda Hierarchy'deki boşluğa yani sample scene altındaki boşluğa sağ tıklayınca altta Cinemachine'i göreceksin, 
cinemachine yanında açılan kısımdan da cinemachinecameraya tıklayarak ekle.

- Main camera objectine tıklayınca sağda inspector altında Cinemachine brain'i göreceksin.

- Cinemachine kameranın player objectimizi sürekli takip etmesini istiyorsak, cinemachine cameraya tıklayıp
sağdaki inspector altında "Tracking Target" kısmında takip etmesini istediğimiz objecti seçeceğiz.

- Kameranın duruş şekillerini cinamachine cameranın inspector'unda Procedural Component altındaki
position control ile kontrol ediyoruz. "Hard lock to target" seçeneği kamerayı objectin tam üstüne yerleştirirken,
"third person follow" seçeneği ise kamerayı tam arkasına yerleştiriyor. 

- Rotation control kısmını da "hard look at" seçeneğine çektiğimizde, bu kısım kameraya nerede olursan ol 
playera bak ancak bunu rotation point of view'dan yap diyoruz. Bunu ayarladıktan sonra cinemachine kamerayı
üzerindeki koordinat sistemini gösteren okları kullanarak hareket ettiremiyorum, bunu çözmenin yolu da 
yine inspector altında cinemachine follow kısmında "follow offset" ayarının Y değerini manuel olarak değiştirmek.

- "Cinemachine camera hard look at" kısmındaki "look at offset" değeri ise playerın tam üstünü hedef almanı değiştiriyor.
Bunu player üzerinde olan sarı kareden anlayabilirsin. Buradaki offset değerlerini değiştirerek kamerayı player'ın biraz
üstüne ya da altına odaklamak mümkün.

- "Cinemachine Follow" kısmındaki "follow offset" değerini değiştirdiğinde, objectin üzerindeki sarı kare sabit 
kalacak şekilde ya daha yukarıdan bakıyorsun ya daha sağdan bakıyorsun gibi ayarlamaları yapıyorsun ancak "Cinemachine
Hard Look At" altındaki "Look at offset" değeri ise cameranın odağını değiştiriyor yani object üzerindeki sarı kareyi değiştiriyor.

- Burada Procedural Component altındaki Position Control ve Rotation Control kısımlarında seçtiğin seçeneklere göre aşağıda
kamera ayarlama seçenekleri açılacak. Position Control'ı Follow olarak ayarlarsan aşağıda Cinemachine Follow açılacak ve oradan
Follow Offset ayarlarını ayarlayabileceksin.

- Rotation Control kısmında Hard Look At seçeneğini seçmen durumunda altta çıkan ayarlardan Cinemachine Hard Look At kısmında
Look at Offset değeri kameranın bulunduğu yer sabit kalacak şekilde baktığı yerin rotational ayarının yapılmasını sağlıyor.

- Bütün bu ayarlamaları yaptıktan sonra oyunu başlattığımızda kamera objectin hareketlerini biraz gecikmeli olarak
takip ediyor, bunun ayarlamasını da "damping" kısmından yapacağız.

- Position damping kısmındaki X değerini 0 yaparsan, object x ekseninde hareket ederken kamera da onu herhangi bir gecikme
yaşamadan takip eder. Buradaki değerlerle eksenlerdeki kamera hareketlerinin gecikmeli olup olmamasını kontrol edebiliyorsun

- Duvar eklemek istediğin zaman cube olarak object ekle ve onu scale ederek istediğin duvar boyutuna getirebilirsin.

- Herhangi bir objectin inspectorı altındaki "Transform" yazısına sağ tıklayıp reset dersen tam ortaya alıyor ve
scale boyutlarını da 1'e çekiyor. 

- Hierarchy içinde "empty game object" oluşturup bunun da Transform değerlerini sıfırladık. Sonra 4 walls objectini ve 4 obstacle
objectini bu oluşturduğumuz ve Environment adını verdiğimiz empty objectin üstüne sürükleyerek bu objectin altında 
gruplandırdık. Bu şekilde modülerliği ve dosyalar üzerindeki kontrolünü artırıyorsun.

- Oyunu çalıştırdığımızda ana objectimiz duvarların ve engellerin içinden geçiyor ancak bunlara çarpmasını istiyoruz.
Burada colliders'lar devreye girecek.

- Player objectinin inspectorunda mesh renderer kısmı checked halinde. Bunu kapatırsak ana objectimizin(cube) yüzeylerini
kaplayan turkuaz rengi duvarlar gidecek sadece Box Collider kalacak. Bu da yeşil olarak gösterilen ve küpün iskeleti.

- Çarpışma olabilmesi için sistemin fizik kurallarına uyması lazım. Bunun için de player'ın yani ana objectin bir mass 
kazamnası lazım. Ana objectin inspectorunda en altta "add component" kısmına gelerek orada "rigid body" ekliyoruz.

- Rigid body içinde mass, linear damping, angular damping ve gravity gibi fiziksel değerler var. Bu objecti dikeyde 
kaldırıp oyunu başlatırsak gravity etkisiyle yere düşecek.

- Artık duvarlardan ya da engellerden geçemiyor ancak engelden geçmeye zorladığında bir titreşim hareketi ve bazen de 
bounce back yapıyor. Bunu engellemek, yani direkt olarak duvarın ya da engelin oraya gelince durmasını sağlamak için
constraint eklememiz gerekiyor, bunu da rigid body içindeki constraints'den yapıyoruz.

- Constraints içinde duvarla collisin durumunda rotational şekilde bounce back hareketini önlemek için rotation kısmındaki
bütün eksenleri donduruyoruz. Yüzeyde de x ve z ekseninde ilerlediğimiz için herhangi bir collisin durumunda y eksenindeki 
hareketlerin de durmasını istiyoruz. Bundan dolayı constraint altındaki freeze position kısmından da y'yi checked durumuna
getiriyoruz.

- Eğer oyundaki bir objectinin inspectorunda box collider yoksa ya da ona hangi collider türü uygunsa ve o collider türü
yoksa o zaman ana object onun içinden geçebilir.

- Bir objectin box collider'ı içinde edit collider'ı actif hale getirirsek object üzerinde yeşil noktalar göreceksin
Bu noktaları çekip uzatarak object ile collide edeceği yeri mesh'inden farklı konuma getirebilirsin.

- Box collider içinde isTrigger kutucuğu var. Bunu checked hale getirirsen object ile collide etmiyor, yani içinden 
geçiyor ancak içinden geçtiğinde bir şeyler triggered hale geliyor. Kapıdan geçince karşısına canavar çıkan bir 
oyun tasarlayacağımız zaman kapıdan geçtiğinin kontrolünü isTrigger ile yapıyoruz. Bu bizim koda bir mesaj gönderecek,
biz de kapıdan geçince ne olacağını kod bloğunda yazmış olacağız ve orası çalışacak.

- Bir object'in "mesh renderer" kısmındaki kutucuğu kapatırsan sen development kısmında bunun iskeletini görebilirsin ancak
oyuncu bunu göremez. Bunu kapatıp isTrigger seçeneği işaretlenirse oyuncu rastgele geçtiği bir yer sonucunda başına geleceği
kod dosyanda ayarlayabilirsin. Bir kapıdan geçince karşısına canavar çıkması gibi...

- 
void PrintInstructions()
    {
        Debug.Log('Welcome to the game!');
    }
Bu kod bloğunun yapacağı şey unity içindeki console'da görünecek. Bu metodun console'da bir kere 
görünmesini istiyorsam start() metodu içinde çağıracağım.

- 
using UnityEngine;

public class Mover : MonoBehaviour
{
    [SerializeField] int moveSpeed = 10;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        PrintInstructions();

    }

    // Update is called once per frame
    void Update()
    {
        MovePlayer();
    }

    void PrintInstructions()
    {
        Debug.Log("Welcome to the game!");
    }

    void MovePlayer()
    {
        float xValue = Input.GetAxis("Horizontal") * Time.deltaTime * moveSpeed;
        float yValue = Input.GetAxis("Vertical") * Time.deltaTime * moveSpeed;
        float zValue = 0f;
        transform.Translate(xValue,yValue,zValue);
    }


}

Bu işlemlerin metodlar altında bu şekilde yapılması ve gerektiğinde o metodların çağrılması
kodun daha modüler ve üzerinde daha cok kontrol sahibi olmamızı sağlıyor

- Şimdi de oyun içindeki engellere ya da duvara çarpınca console'da uyarı verdirten bir script 
yazacağız. Önce "ObjectHit" isminde bir script oluşturup bunu environmenttaki bütün obstacle ve 
wallara bağlayacağız. Burada da oluşturacağımız script tipi monobehaviourscript.

- Birden fazla object'e aynı scripti bağlarken objectlere ctrlye basılı tutarken tıkla ve sonra 
sağ altta add component kısmından script adını yani ObjectHit'i arat ve ekle.

- Buradaki script dosyasını açtıktan sonra start ve update metodlarını silebilirsin. Bunlarla işimiz
yok. Bunun yerine onCollisionEnter metodunu yazman lazım.

- 
void OnCollisionEnter(Collision collision)
    {
        
    }
buradaki metodda şimdilik parametreye ihtiyacımız yok, çünkü sadece çarpma bilgisini toplayacağız ancak
kimin obstacle'a ya da Wall'a çarptığını öğrenmek istiyorsak o zaman işte buradaki parametre işimize 
yarayacak.

- 
using UnityEngine;

public class ObecjtHit : MonoBehaviour
{
     void OnCollisionEnter(Collision collision)
    {
        Debug.Log("Something hit me!!!");
    }
}

Bunu yazdıktan sonra oyunu başlattığımızda duvara carptıgımızda bu mesajı görüyoruz ancak duvara
çarpma yönündeki oka basılı tuttuğumuzda bu mesaj yüzlerce kez consoleda yazdırılmıyor.
Eğer objecti duvardan biraz uzaklaştırıp tekrar çarparsak o zaman yine bu mesajı görüyoruz.

- Şimdi de ana object bir yere carptıgında o çarptığı object renk değiştirsin istiyoruz. Bunu nasıl
yapacağız ? Öncelikli olarak bir objectin componentlerine bakacağız. Mesh renderer, box collider ve script var.
Eğer bir objecte script bağlı ise o scripti kullanarak  componentler hakkında bilgi çekebiliriz. Mesela duvarın mesh renderer'ının altında
material kısmı var orada da blue kısmı var. Duvara script bağlı olduğu için, burayı script üzerinden değiştirebiliriz.

- 
 void OnCollisionEnter(Collision collision)
    {
        GetComponent<MeshRenderer>().material.color = Color.red;
        Debug.Log("Something hit me!!!");
    }

GetComponent<MeshRenderer>().material.color = Color.red; bu kod satırı mesh renderer
componentini al ve onun material altındaki color'ını değiştir diyor. Burada GetComponent
keyword'üne dikkat et, bunu cok kullanacaksın.

- Şimdi de player'ın çarpma sayısını console'da yazdırmak istiyoruz ya da diğer bir deyişle
score tutmak istiyoruz. Bunun için önce Scorer diye bir script oluşturup ana objectimize bağlıyoruz.
Sonrasında da içinde onCollisionEnter metodunu oluşturuyoruz ve çarpma sayısını integer değer ile orada
tutuyoruz.

using UnityEngine;

public class Scorer : MonoBehaviour
{
    int Score = 0;
    void OnCollisionEnter(Collision collision)
    {
        Score++;
        Debug.Log("You bumped into this many times: "+ Score );
    }
}
Her çarpmada fonksiyon tetiklenecek ve score değişkeni bir artacak ve onu da console'da yazdıracak.


- Burada dikkat et, player objectine yani ana object'e iki tane script bağlı biri Mover, diğeri de 
Scorer. Mover içinde ana fonksiyonlar olan start ve update var, Scorer içinde ise çarpışmayı
anlayacak fonksiyon ancak ikisi de aynı anda çalışabiliyor.

- Rotate ederken E tuşuna basıyorduk, eğer E tuşuna basıp rotate modunu açıp sonra control tuşuna basılı
tutarak rotate edersen o zaman açılı olarak rotate edebiliyorsun.

- transform.Rotate(2,3,4); bu kod scriptini bağladığın objectin rotate etmesini sağlıyor.

- Project Settings -> Player kısmından Active Input Handling'i "old ya da both" kısmına çekmezsen update metodu
içinde tanımladığın float x = Input.GetAxis("Horizontal"); satırı hata verdiriyor. Bu kod eski sisteme ait.

- Empty game object oluşturup oyundaki duvarlar ve engelleri bunun altına koyarsan, o game objecti hareket ettirdiğin
anda altındaki bütün objectler aynı oranda hareket edecek.

- Box Collider checked halde olsa bile "is Trigger" checked durumunda ise herhangi bir collision olmayacak,
ana object içinden geçecek ancak içinden geçtiği anda kodda bir uyarı göreceğiz.

- Console'a yazdırdıklarını sadece developer görebilir, PS kullanıcıs yazdığın oyunda console'da olanı göremez. 
Bu kısmı oyunu cogunlukla debug etmek istediğimizde kullanıyoruz.

- 
using UnityEngine;

public class ObjectHit : MonoBehaviour
{

    void OnCollisionEnter(Collision collision)
    {
        GetComponent<MeshRenderer>().material.color = Color.red; 
        Debug.Log("Collision happened!");
    }

}
Çarpışma olduğunda bu scriptin bağlı olduğu objectin Componentlerinden MeshRenderer içindeki materialın color'ını kırmızı 
yap.


- Time.time entegre edeceğiz, bu şekilde bizim game object oyunun başından beri ne kadar zaman geçtiğini bilecek

- Şimdi burada dropping object oluşturacağız. Bu objecti oluşturup iyice havaya kaldırıyoruz. Burada dikkat et ,
objectin gölgesi ground'a düşüyor. Bu durum oyundaki "directional light" ile alakalı. Directional light objectine tıklayıp
x, y ya da z eksenlerinde hareket ettirirsen gölgede bir değişiklik olmuyor ama rotational bir hareket yaptırırsan gölgenin
konumunda bir değişiklik oluyor

- Burada şöyle bir şey yapmak istiyoruz, oyun başladıktan 3 saniye sonra havada asılı bıraktığımız object yere düşsün.
Bunun için de Time.time kullanacağız ve sonrasında if yapısı ile 3 saniye geçtiğini kontrol ettikten sonra 3 saniye sonra 
gravity'i tekrar enable durumuna çekeceğiz.

- Burada önce Dropper.cs scriptini oluşturduk ve Dropper objectimize bağladık sonra her bir framede console a ne kadar zaman geçtiğini göstermek 
için alttaki kodu yazdık

using UnityEngine;

public class Dropper : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        Debug.Log(Time.time);
    }
}

- 
using UnityEngine;

public class Dropper : MonoBehaviour
{
    [SerializeField] float timeToWait = 2f;
    void Start()
    {
        
    }
    void Update()
    {

        if (Time.time > timeToWait)
        {
            Debug.Log("Start falling!!!");
        }   
    }
}


- Time olayını hallettikten sonra şimdi de objectin düşebiliyor olması lazım. Bununn için de dropper objectine
rigid body componenti ekleyeceğiz. Ancak burada object düşmeden önce invisible olmasını istiyoruz, bunun için de
mesh renderer ve box collider componentlerini disabled etmemiz gerekiyor. Bunu da kodda GetComponent kullanarak 
yapacağız. Aynı şekilde gravity özelliğini de GetComponent kullanarak enabled ya da disabled yapacağız.

- GetComponent<MeshRenderer>().enabled = false;
bu kod satırını start() fonksiyonu içinde yazarak MeshRenderer özelliğini en başta disabled ediyoruz.

- MeshRenderer'ı bir değişkende tutmak istediğimizde "caching" terminolojisini kullanıyoruz.

- (Def) caching is a technique of storing frequently used data or information in memory, so that it can 
easily be accessed when needed.

- MashRenderer'ı bir değişkende tutmak istediğimizde oluşturacağımız değişkenin tipi MeshRenderer olacak. Flutter'da
object tiplerini o objectleri tanımlarken kullandığımız zamanki durum burada da aynen geçerli.

-
public class Dropper : MonoBehaviour
{
    [SerializeField] float timeToWait = 2f;
    MeshRenderer myMeshRenderer;
    void Start()
    {
        myMeshRenderer = GetComponent<MeshRenderer>();
        myMeshRenderer.enabled = false;
    }
…
Burada MeshRenderer'ın bütün içeriğini artık myMeshRenderer değişkeninde tutuyoruz


- Aynı şekilde caching i rigid body'e de uygulayacağız.

using UnityEngine;

public class Dropper : MonoBehaviour
{
    [SerializeField] float timeToWait = 2f;
    MeshRenderer myMeshRenderer;
    Rigidbody myRigidBody;
    void Start()
    {
        myMeshRenderer = GetComponent<MeshRenderer>();
        myMeshRenderer.enabled = false;
        myRigidBody = GetComponent<Rigidbody>();
        myRigidBody.useGravity = false;
    }
    void Update()
    {

        if (Time.time > timeToWait)
        {
            Debug.Log("Start falling!!!");
        }   
    }
}


- Belirli bir süre sonra visible olmasını ve yere düşmesini istiyorsak o zaman update fonksiyonu altında ve if statementı içinde
yukarıda false yaptığımız özellikleri true'ya çekmemiz gerekiyor.

using UnityEngine;

public class Dropper : MonoBehaviour
{
    [SerializeField] float timeToWait = 2f;
    MeshRenderer myMeshRenderer;
    Rigidbody myRigidBody;
    void Start()
    {
        myMeshRenderer = GetComponent<MeshRenderer>();
        myMeshRenderer.enabled = false;
        myRigidBody = GetComponent<Rigidbody>();
        myRigidBody.useGravity = false;
    }
    void Update()
    {

        if (Time.time > timeToWait)
        {
            myMeshRenderer.enabled = true;
            myRigidBody.useGravity = true;
        }   
    }
}


- Bir objectin üzerine tıklayınca sag tarafta tag kısmı var. Orası bize oyun içinde objectlerle ilgili ek bilgi vermesi için önemli. Şu an 
bütün objectler untagged şeklinde duruyor.

- Asıl player objectinin tag değerini "player" olarak değiştiriyoruz.

- Şimdi ObjectHit.cs dosyasına gelip burada şöyle bir düzenleme yapacağız. Sadece ana object sana çarparsa renk değiştir. Bunu şundan dolayı
istiyoruz, dropper objectine rigid body eklediğimiz için ground'a değdiği anda o da renk değiştiriyor. Bu durumu değiştirmemiz lazım.

- 
using UnityEngine;

public class ObjectHit : MonoBehaviour
{

    void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.tag == "Player")
        {
            GetComponent<MeshRenderer>().material.color = Color.black; 

        }        
    }

}
Bu kod bloğunda eğer collision'ı gerçekleştiren game objectin tag'i "Player" ise renk değişimi gözlensin demek istedik. Artık yukarıdan 
düşen ve ground ile çarpışan objectin rengi değişmeyecek.


- 
using UnityEngine;

public class ObjectHit : MonoBehaviour
{

    void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.tag == "Player")
        {
            GetComponent<MeshRenderer>().material.color = Color.black;
            gameObject.tag = "Hit";

        }        
    }
}
Bu kod bloğundaki şu satırla gameObject.tag = "Hit"; 
şunu demek istiyoruz, eğer ben "Player" tag'ine sahip bir object tarafından 
çarpılmışsam bu player tarafından çarptığım gameobject'ine "Hit" tagini ata. 
Burada dikkat etmen gereken asıl nokta eğer "Hit" değerini sen Unity içinde sağ taraftaki Tag bloğuna eklemezsen
o zaman kodda hata alıyorsun. "Hit" değerine sağda bulunan tagler arasına ekle
ondan sonra kodda düzenlemelerini yap

- Şimdi de daha önce çarptığım bir objecte bir daha çarpmam durumunda scoreKeeper'ın tekrar artmasını
istemiyorum. Bunu da Scorer.cs scriptinde

using UnityEditor.Rendering;
using UnityEngine;

public class Scorer : MonoBehaviour
{
    [SerializeField] int scoreKeeper = 0;
    void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.tag != "Hit")
        {
            scoreKeeper++;
            Debug.Log("You bumped into " + scoreKeeper + " this many times");

        }
    }
}

- Şimdi de obstacleların rotate etmesini istiyoruz.

- Şöyle bir sorunla karşılaştın: Bir object oluşturduktan sonra scale ederken bir eksende continuous şeklinde scale edememeye başladın
Bunun sebebi de şu, oyun ekranının yukarısında Toggle Grid Snaping denilen bir yer var, grid önünde mıknatıs işareti bulunan bir yapı.
Eğer burayı aktif edersen scale işlemini continuous halde yapmak yerine blok blok yapıyor. Yani bir anda 3 blok ya da 4 blok artırıyor.
Burayı şimdilik kapalı tut.

- Rotate için object oluşturduktan sonra bu objecti ObjectHit.cs ile bağlıyoruz sonra da Spinner.cs scripti oluşturup onu da 
objecte bağlıyoruz.

- Bir objecting rotate eksenini nasıl anlıyoruz. Object dönerken oluşturduğu hayali yüzeyin normal vektörü o objectin unitydeki rotation ekseninin ne 
olduğunu veriyor.

using UnityEngine;

public class Spinner : MonoBehaviour
{
    [SerializeField]float xRotation = 0f;
    [SerializeField]float yRotation = 0.5f;
    [SerializeField]float zRotation = 0f;

    void Start()
    {
        
    }
    void Update()
    {
        transform.Rotate(xRotation,yRotation,zRotation);
    }
}


- Şimdi de bir sphere object ekledik ve projectile yapmasını sağlayacağız. Bunun hareket için Vector3 kullanacağız.
We can store Vector3 as a variable.  C’est une variable (par exemple, la position) qui contient trois valeurs (x, y, z)
Move Towards() metodunu da aynı zamanda kullanacağız. We can use MoveTowards() to make an object move towards a specific point 
in the World. 

- Vector3 is a position in the World, it contains values for x,y,z

- MoveTowards() 3 parametre ister,
	1- o anki pozisyonu(current)
	2- gideceği noktanın pozisyonu(target)
	3- maxDistanceDelta = distance to move each time(how much to move each time we call MoveTowards())
MoveTowards(actuel, cible, distanceMaximale)

- transform.position = Vector3.MoveTowards(transform.position, playerPosition, 1f);
Bu kod satırını update metodu içinde yazıyoruz ve bu kod satırı sayesinde update metodu her çalıştığında scriptin bağlı
olduğu object player'ın konumuna doğru gidecek. Soldaki ifade scriptin bağlı olduğu objectin konumunu tanımlıyor.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{
    Vector3 playerPosition;
    void Start()
    {
        
    }
    void Update()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, 1f);
    }
}
Bu kodda playerın position'ı nerede? Player kim ? Bunları belirtmemiz gerekiyor yani we need to reference to the player
Burada ne yapacağız? İki objecti Inspector içinde birbirine bağlayacağız. Bunun için de Unity'deki bütün objectlerin sahip
olduğu Transform componenti üzerinden bağlayacağız.

using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Start()
    {
        
    }
    void Update()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, 1f);
    }
}

Bu şekilde yazdığında, yani player'ı Transform tipinde oluşturup bunu serializefield olarak tanımladığında 
Unity içinde Projectile objectine tıklayınca sağda açılan Inspector altındaki FlyAtPlayer.cs scriptinin orada
"Player" yazacak ve sağ tarafında ise None(Transform) yazacak. Transform üzerine tıklayıp oradan işte ana objectimizi
yani asıl playerı seçiyoruz.

- playerPosition = player.transform.position; Bu kod bloğunu da start altında yazınca işte şimdi player'ın position'ını 
alacağız. Bunu neden start altında yazıyoruz, çünkü oyunda player sabit ve playerın olduğu yere doğru eğik atış yapacak 
bir sphere var. Diyelim ki eğer bir roket tasarlayacak olsaydık o zaman ana object roket olacağından ve bunun da position değerleri
sürekli değişeceğinden dolayı işte bunun positionını update altında alacağız.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] float speed = 1.0f;
    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Start()
    {
        playerPosition = player.transform.position;
    }
    void Update()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, Time.deltaTime * speed);
    }
}
Burada projectile motion'ı framerate independent hale getirdik bunu da MoveTowards fonksiyonundaki her çağrılmasında ne kadar ilerleyeceğini
gösteren parametre yerine yazdık.

- Inspector altındaki BoxCollider asla kullanıcı tarafından görülemez, açık olsa da olmasa da görülemez ancak bir objectin visible
ya da invisible olmasını istiyorsak o zaman Mesh Renderer ayarı ile oynamalıyız.

- 

using UnityEngine;

public class ObjectHit : MonoBehaviour
{

    void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.tag == "Player")
        {
            GetComponent<MeshRenderer>().material.color = Color.black;
            gameObject.tag = "Hit";

        }        
    }
}
Buradaki  if (collision.gameObject.tag == "Player") kod satırında denmek istenen şey şu:
other things that bumped into us and I want to access the game object itself, bunun da tag'inin Player olması durumunda if
içindeki işlemleri yap. İçerideki collision.gameObject.tag ile gameObject.tag arasındaki fark, ilkinde bu scriptin bağlı
olduğu objecte çarpan objecti refer ederken gameObject.tag kısmında ise bu scriptin bağlı olduğu objecti refer ediyor.

- 3D object altında plane oluşturduğunda, bunun transform altındaki scale kısmına ne kadar y değeri girersen gir, herhangi
bir boyut değişimi göremeyeceksin. Plane 2 boyutlu bir object, o yüzden sadece x ve z değerleri için değişimi görebilirsin.

-  transform.position = Vector3.MoveTowards(transform.position, playerPosition, 1f); Update içinde frame her cagrıldıgında 
objectin transform içindeki position değerleri MoveTowards metodundan dolayı güncellenecek. Yani cisim hareket edecek, bu
hareketten sonra oluşan yeni x,y,z positionları transform.position'a atılacak yani cismin konumu değişecek.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] float speed = 1.0f;
    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Start()
    {
        playerPosition = player.transform.position;
    }
    void Update()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, Time.deltaTime * speed);
    }
}
Buradaki bu kod satırından dolayı [SerializeField] Transform player; Unity arayüzünde sağ tarafta bir player ataması yapmamız gerekiyor.
Bu player'ı projectile yapacak objectimiz olarak tanımlıyoruz, çünkü bu objectin gideceği yer bizim ana playerımızın olduğu konum.

- Şimdi bu aşamada da objectleri yok etme konusunu ele alacağız.

- 
    void DestroyWhenReached()
    {
        Destroy(gameObject);
    }
Burada yok etme metodunu tanımlarken hangi objecti yok edeceğimizi belirtmemiz gerekiyordu. Bu scriptin yani FlyAtPlayer.cs scriptinin
bağlı olduğu objectleri refer etmek için ya da herhangi bir scriptin bağlı olduğu bir objecti refer etmek için "gameObject" kavramını kullanıyoruz.

- Inspector altındaki meshrenderer'e sağ tıklayıp remove diyerek de eklediğimiz objectin iskeletinin kalmasını sağlayabiliyoruz.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] float speed = 1.0f;
    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Start()
    {
        playerPosition = player.transform.position;
    }
    void Update()
    {
        MoveToPlayer();
        DestroyWhenReached();

    }
    void MoveToPlayer()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, Time.deltaTime * speed);

    }
    void DestroyWhenReached()
    {
        if (transform.position == playerPosition) {
            Destroy(gameObject);

        }
    }
}

- Şimdi de trigger olayını halledeceğiz. Ana objectin yakınında cube bir object koyup MeshRenderer'ını kapatacağınız, 
çünkü objectin varlığını değil o objectin kapladığı volume'a gelecek objectlerin trigger edeceği olayı halledeceğiz. Bunu yaparken 
de objectin sağda inspector altındaki BoxCollider altındaki isTrigger kısmını enabled yapmamız gerekiyor.

- Burada da aynen Collision'da olduğu gibi  
	void OnTriggerEnter(Collider other)
    {
        
    }
metodunu kullacagız. Collision'da bu void onCollisionEnter(Collision colision){} şeklindeydi.

- Inspector'ın hemen altındaki yer yani tag'in üstündeki yeri unchecked hale getirirsek o object artık görünmüyor, ancak bu durum 
mesh rendererı unchecked etmekten farklı. Orada objectin iskeletini hala görüyorduk ancak burada artık tamamen görmüyoruz.


- tag'in üstündeki yeri kapatabilmemiz için SerializeField olarak GameObject tipinde bir değişken tanımlamamız gerekiyor.

-
using UnityEngine;

public class TriggerProjectile : MonoBehaviour
{
    [SerializeField] GameObject projectile;
    void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Player") {
            projectile.SetActive(true);
        }
    }
}
Öncesinde 5 tane küre şeklinde projectile yapan objectlerin inspectorun hemen altında tag'in hemen üstündeki
yerden unchecked yaparak yok ettik, yukarıdaki kod bloğu da eğer ana objectimiz trigger volume'den geçerse o projectile 
yapan 5 objecten bir tanesi, ki bunu SerializeField olarak tanımladıktan sonra unity arayüzünde Projectile isimli object'e 
target ettirdik, yani bu object bir anda görünür olacak. Ana object o trigger volumedan geçtiği anda Projectile isimli object de 
görünür olacak, bunu da projectile.SetActive(true); satırıyla yapıyoruz.

- 
using UnityEngine;

public class TriggerProjectile : MonoBehaviour
{
    [SerializeField] GameObject projectile;
    [SerializeField] GameObject projectile2;
    [SerializeField] GameObject projectile3;

    [SerializeField] GameObject projectile4;
    [SerializeField] GameObject projectile5;


    void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Player")
        {
            projectile.SetActive(true);
            projectile2.SetActive(true);
            projectile3.SetActive(true);
            projectile4.SetActive(true);
            projectile5.SetActive(true);
        }
    }
}
O 5 objecti de SerializeField olarak tanımlayıp, inspector içinde atamalarını yapıp hepsini ana object trigger volume'den geçince
ortaya çıkacak şekilde ayarlayacak kod bloğu yukarıda.

- Prefab : reusable asset that represent a GameObject. Bunu harddrive'a prefab olarak kaydediyoruz.
Instance : specific copy of a prefab in our scene

- Burada 5 tane objecti teker teker duplicate ederek oluşturduk ancak ben kürenin yarıçapını değiştirerek
oluşturmak istiyorum, bu durumda her duplicate ettiğimde ayrı ayrı ayarlamalar yapmak zorunda kalacağım. Instance ve
prefab olayı bu ayarlamaları teker teker yapmamak için var. Burada sadece bir tane projectile objecti bırakarak diğer 4ünü
sildik.

- Sonrasında asset içine gelerek Prefab adını verdiğimiz bir folder oluşturduk. Sonrasında solda Hierarchy içinde, prefab yapmak istediğimiz gameobjectin üzerine 
gelip o folderın içine sürükleyerek bırakıyoruz. Hierarchy içinde o gameobject, bu durumda projectile oluyor, mavi bir simge solunda bulunacak şekilde duruyor. 
Asset içindeki Prefab folderındaki Projectile'a sağ tıklayıp "Show in Explorer" dediğimizde artık uzantısının prefab olduğunu görüyoruz. Yani bu object artık
prefab oldu ve hard drive'da duruyor. That's a great way to share particular things from game to game. If you go to the asset store and purchase an asset, then you will be 
able to download it as a package ve bu package file içerisinde birçok prefabs bulunuyor.

- Objecti prefab durumuna getirdikten sonra eğer hierarchy içindeyken yanlışlıkla bu objecti silersem, hala prefab içinde durduğundan dolayı, buradan tutup sürükleyerek objecti
tekrar oluşturabilirim, buna instance diyoruz ve tekrar sürükleyip bırakırsam yine aynı şekilde bu sefer ikincisi oluşur, projectile (2) oluşur.

- Sol tarafta 4 tane instance'ın scale değerlerini değiştirmek istiyorum, o zaman tek tek yapmak yerine prefab folderı içindekine çift tıklayınca oyun ekranında
bizi sadece o objectin olduğu yeni bir yere yönlendiriyor ve orada ayarlama yaptıktan sonra genel oyun yerine geldiğinde bütün instanceların aynı değeri aldığını görüyorsun.

- Bir Instanceın Inspectorı altında Prefab kısmında Overwrite seçeneği var. Eğer bir instance'ın scale değerini değiştirirsen Overwrite altında Revert all ve apply to all kısmı var.
Revert all, başlangıç değerlerine getirirken, apply to all hepsine artık bu değeri uygulayarak prefab'in de değerini değiştiriyor.

- Burada şöyle bir istisna var. Bu 5 sphere objecte colourları sınıflandırdığımız materiallerdan bir colourı birine atadık, sonra atadığımız objectin prefabi altına gelip
overwrite kısmından apply to all diyince bütün hepsi o colora sahip olacak ancak diyelim ki önce birine bir color atadım sonra apply to all demeden sonra diğerine color atadım. 
Bunlardan birinin overwrite kısmından apply to all dersem o zaman diğer ikinci olan hariç hepsi o renge bürünecek. Apply to all kısmı diğerine etki etmeyecek.

- Prefab yapacağın objectleri seçerken dikkat et. Ana player kesinlikle prefab olmalı çünkü scene'den scene'e geçerken bunun kalmasını istiyoruz. Her şeyi prefab içine de taşıyabilirsin.

- Eğer instance'ı duplicate edersen o oluşan aynı object de aynı prefab'den oluşmuş gibi olacak, sürükleyip bırakmanla hiçbir farkı olmayacak.

- Prefablerin hepsini etkileyecek bir değişiklik yapacaksan eğer 2 yolu var: Prefab folder'ı içindekine tıklayarak sağda Inspector altında yapabilirsin ya da instancelardan birini 
değiştirip apply to all diyebilirsin.

- Burada çalıştırdıktan sonra hata alıyoruz çünkü destroy edilen bir objecte sonradan erişmeye çalışıyorsun. Bu neden oluyor? Projectile yapan bir objectler senin bulunduğun konuma doğru 
geliyor ancak sen hala trigger volume'den geçmedin. Objectler sana çarpıp da yok olduktan sonra trigger volume'den geçmek istersen exception atıyor, çünkü trigger volume'den geçmesi
durumunda o objectlere erişip bir şeyler yapacak kodu yazmıştık.

- Unity'nin event functionlar için order of execution'ı var. Unity documentation'da execution order kısmında "Awake" diye bir şey var. Burası Start'tan da önce çalıştırılıyor.
Bundan dolayı öncesinde calıstırılması gereken kodlar varsa bunları Awake içine atmamız lazım.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] float speed = 1.0f;
    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Awake()
    {
        gameObject.SetActive(false);
    }
    void Start()
    {
        playerPosition = player.transform.position;
    }
    void Update()
    {
        MoveToPlayer();
        DestroyWhenReached();

    }
    void MoveToPlayer()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, Time.deltaTime * speed);

    }
    void DestroyWhenReached()
    {
        if (transform.position == playerPosition) {
            Destroy(gameObject);

        }
    }
}
Bu dosya FlyAtPlayer.cs dosyası. Bunlar projectile yapan objectlere bağlı olan dosya. Bu şekilde awake fonksiyonu eklememizin ana nedenlerinden bir tanesi,
ana object trigger volume'den geçmeden önce projectilelar herhangi bir görünürlük elde etmiyor, ya da harekete geçmiyordu ancak trigger volume'den geçtikten sonra harekete
geçiyordu ancak bu harekette şöyle bir sorun var, projectilelar ana objectin o anlık konumuna gelmiyorlar, başlangıç konumuna gidiyorlar ancak biz trigger volume'den geçtiği
anda oluşsunlar ve o an ana object neredeyse oraya gelsinler istiyoruz. Buradaki sorun order of execution'dan kaynaklanıyor. Awake fonksiyonu bu sorunu düzeltme amacıyla
kullanıldı.

- Hierarchy içinde bir game objectin solundaki göz işareti kolonuna tıklarsan o object scene içinde görünmüyor ama bu yok olduğu anlamına gelmiyor, hala var sadece tasarım yaparken
ya da bir şeyleri ayarlarken dikkatin dağılmasın diye ayarlamak için.

- Oyun içinde bir objecte özellikle ground objectine yanlışlıkla tıklama cok oluyor, bunu kapatmak için hierarchy içinde el işareti olan kolonda tıklamak istemediğin objectin hizasına tıklaman
lazım.

- Bütün walların position'daki y değerlerini aynı yaptık,sebebi de aynı yüksekliğe sahip olmalarını istememiz.

- Bütün objectleri individual olarak seçip rotate ettirirsen her object bulunduğu noktada rotate edecek ancak empty game object altında gruplandırıp o grubu rotate ettirirsen oyun alanı bir bütün olarak
dönecek, bundan dolayı gruplandırmalar önemli.

- TriggerProjectile.cs

using UnityEngine;

public class TriggerProjectile : MonoBehaviour
{
    [SerializeField] GameObject projectile1;
    [SerializeField] GameObject projectile2;
    [SerializeField] GameObject projectile3;
    [SerializeField] GameObject projectile4;
    [SerializeField] GameObject projectile5;

    void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Player")
        {

            projectile1.SetActive(true);
            projectile2.SetActive(true);
            projectile3.SetActive(true);
            projectile4.SetActive(true);
            projectile5.SetActive(true);
            Destroy(gameObject);
        }
    }
}
Burada Destroy(gameObject); yazdığımızda bu scriptin bağlı olduğu objecti yok ediyor. Bir scriptin bağlı olduğu object ile ayarlamalar yapmak için gameObject kullanıyoruz.
Burada bunu yapmamızın nedeni, trigger volume olduğu yerde kalıyor ancak bundan ikinci defa geçince tekrar projectileları aktif etmeye çalışıyor ancak o projectilelar çoktan yok oldu
bunda da kod exception atıyor bundan dolayı trigger volume'u yok etmek en iyisi.

- Projectile'ların da player'a carptıgında renk değiştirmesini istiyoruz, bu durumda yapacağın şey şu, prefab'lardan projectile'a geleceksin, add component kısmından da ObjectHit.cs'i ekleyeceksin,
böylece bütün projectilelar tek seferde scripte bağlanmış olacak.

- Bir objectin Transform kısmını reset yapabileceğin gibi, bütün değerleri kopyalayıp başka bir objecte de yapıştırabilirsin.

- Hierarchy içinde bir tane empty game object oluşturup, "projectile hazard" bunun altına projectilelar ve trigger volume'u ekledik. Prefab olayının güzel tarafı bu altında 
gruplandırma yaptığımız empty game objecte de prefab olayını yapabiliyoruz. Trigger volume de bir prefabdi, burada nested prefab de yapabilirsin.

- Unity'de küçük bir sorun var nedenini bulamadım ama çözüm var. Bir yerden sonra Mouse'la game scene içinde gezinme hızın cok yavaşlıyor. Mouse'un döndürdüğün o yuvarlak kısmı ile
yaklaşıp uzaklaşma hızın bir noktada cok cok yavaşlıyor, sağ click ile dönme hızın da cok yavaşlıyor, bu durumda bir objecte tıklayıp "F" tuşuna basınca o objecte hızlıca odaklıyor kamerayı ve
Mouse ayarları da normal hızına dönüyor. Çok saçma bir sorun ve çözüm.

- NEW PROJECT (ROCKET)

- Bu projedeki game design felsefesi
	Player Experience : Precision, skillfull
	Core Mechanic : fly carefully and avoid environmental hazard
	Core Game Loop : Get from A to B

- Aynı zamanda ayını tasarlarken game flow and screens kısımlarını da flowchart şeklinde tasarlaman lazım. Level 3'te yanarsan Level1'a dönmeyeceksin, Level3'te tekrar edeceksin gibi...

- Bu projede başka bir projeden import edeceğimiz game objectleri kullanacağız bunun için de .unitypackage uzantısına sahip dökümanı projemizde Assets folderının içinde istediğimiz yere
sürükleyip bırakabiliriz. Sonrasında bu package'de bütün objectler karşımıza çıkacak import butonuna bastıktan sonra Assets folderımızda yeni bir Directory oluşacak ve burada import ettiğimiz package'deki
dataları göreceğiz.

- Models dosyası içinde Fighter, Rover gibi oyundaki elemanlar var. Eğer burada bir elemanı anlamsız bir renkte ve şekilde görürsen, bu case'de pembe, o zaman inspector altındaki Material kısmına gel ve 
colour palette kısmından düzenlemeler yap, içerisinde pembe renk olan bütün objectler için bu düzenlemeleri yap.

-  Burada dikkat etmen gereken nokta, bu oyunu sen 3D eksende yapıyorsun ancak 2D'de ilerleyecek o yüzden +x, -x, +y ve -y eksenlerini ayarlayacak şekilde scene'de kamera görüşünü ayarla.

- Eğer import ettiğin bir modeli unity içinde kullanırken boyutlarını merak ediyorsan, rastgele bir cube oluştur, bunun scale boyutları 1,1,1'dir ve bu küpü kıyaslamak istediğin objectin 
yanına getirerek boyut kıyaslaması yap, ya da scene yüzeyi karelere bölünmüş durumda, bu kareler de unity içinde 1 birim uzunluğa denk geliyor, küp oluşturmadan buna bakarak da kıyaslama 
yapabilirsin.

- Burada önce 3 boyutlu bir küp oluşturarak bunu ground yaptık, sonrasında ise modellerden bir tane launch pad bir tane de landing pad alarak küp üstünde yerleştirdik ve rocketi de launch pad
üzerine koyduk. Şimdi burada bu Scene'i kaydetmek istiyoruz,ayrı kaydetmek istiyoruz çünkü bundan oynamalar yapacağız. Sol üstte File 
kısmına gelip "Save as" diyerek bu scene'i "Sandbox" adını vererek kaydediyoruz ve SampleScene'i siliyoruz.

- Sonrasında burada Assets altında Scripts folderını oluşturup içerisine de "Movement" adında monobehavior scripti yerleştirdik.

- 
using UnityEngine;

public class Movement : MonoBehaviour
{
    void Start()
    {
        
    }
    void Update()
    {
        
    }
}
Buradaki UnityEngine = namespace
Class adı da Movement.

- Namespaces are "containers" for Classes and Classes are containers for Variables and Methods.

- Burada highest level => Namespace. Bunları küme olarak düşünürsen en dışarıda evrensel küme olarak Namespace, sonra altında class, class kümesi içinde 
metodlar ve metodlar içinde de statementlar.

- Encapsulation is kind of a putting a capsule around it so it only knows abput itself. The goal is to limit what the code can see / can change / be changed by 
Burada amaç eger bizim elimizde, diğer şeyleri biz farkında olmadan değiştirebilecek bir şey varsa, bunun sonunda istenmeyen durumlar ortaya çıkabilir, bug, ya da 
istenilen dışında movementlar gibi...

- Eğer encapsulation mantığında ilerleyeceksek, bizim Movement.cs kodunda, sadece burası roketin hızını değiştirebilir.

- We typically aim for a class to do one main thing and not multiple things…

- Mesela diyelim ki Movement class sadece hızı ayarlıyor ancak bir yerde de booster classı var ve bu da hızın artırılmasını sağlıyor. Booster classı 
hızı artırmak istediğinde movement classı ile bağlantı kurması gerekiyor, çünkü biz hız konusundaki talimatları sadece movement classından veriyoruz.

- Unity'de unity ekibi tarafından tanımlanmış birçok class var, bunlara erişmek için relevant namespace'i bilmemiz gerekiyor.

- using UnityEngine.InputSystem; bu namespace'i e Movement scriptine ekledik

- By accesing the class, we acces its content using the dot operator. "ClassName.MethodName();"

- Class ve script burada aynı anlamda kullanılacak çünkü burada her bir scriptte bir class var. Normalde bir scriptte birden fazla class yazabilirsin ancak
biz bir scriptte bir class olacak şekilde ayarlayacağız.

- Bir tane empty game object oluşturup, transform değerlerini resetledikten sonra Launch Pad'e yerleştirdiğimiz rocketin de transform değerlerini resetleyip iki
objectin cakısmasını sağlıyoruz sonrasında da rocket objectimizi hierarchy içinde empty game object'in child'ı yapıyoruz. Why did we do this ? What I want to do 
is put all of my scripts and rigidbody and logic onto the parent level, because then it is gonna control everything thats going to go on. It is gonna control the left
and the right. It is gonna control how it moves and the child underneath is just how it looks, it is just a visuals of it. Ne zaman görüntüsünü değiştirmek istesem,
o zaman child'ı silip istediğim şeyi atabilirim empty objectin içine, bütün logic ve scriptleri de parent'a bağladığım için de herhangi bir kaybım olmaz.

- Burada simplest input approach kullanacağız, buna Input Action Bindings in the inspector diyoruz. Input Actions allow us to use multiple input systems(keyboard, controller) to do
specific things in our game. Eg spacebar or trigger to control thrusting.

- Kullanacagımız input system approach'ı için izleyeceğimiz adımlar :
	1- Use the UnityEngine.InputSystem namespace
	2- Create InputAction variables(that are serialized)
	3- Add bindings for each InputAction
	4- Enable each InputAction
	5- Use the value of InputAction for gameplay
	6- Disable each InputAction if/ when we need to turn off input

-
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
}

Burada InputAction typeında bir değişkenimiz var ve şimdi de bunu enable hale getirmemiz gerekiyor.

- Unity'nin dökümantasyonunda order of execution'ı incelerken en üstte Awake fonksiyonu vardı, onun hemen altında da OnEnable fonksiyonu var. Bunlar Start fonksiyonundan 
önce gerçekleşen şeyler. Dökümantasyonda sırasıyla Awake -> OnEnable -> Reset -> Start … ilk dördü oluşturuyor. Initialization kısmında Awake ve OnEnable varken, Editor kısmında 
Reset var ve yine Initialization kısmında Start var.

- It might be you have your game object come alive at the start of the game and then you want to pause it or turn it off when the player dies, and then turn it back on again 
and turn it off and turn it. So the protocol for turning our input actions on and off is to use OnEnable as the callback for turning them on and OnDisable. Bu fonksiyon da 
order of execution'da en alttan bir üstte. En altta OnDestroy fonksiyonu var.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    void OnEnable()
    {
        thrust.Enable();
    }
}

Aynı Start() ve Update() metotlarında olduğu gibi burada da OnEnable metodunu yazıp, InputAction tipindeki değişkenimizi Enable() fonksiyonunu çağırarak enabled duruma getiriyoruz.

- Burada değişkeni SerializeField olarak tanımladık, bundan sonra Unity arayüzüne gelip "Player Rocket" olarak adlandırdığımız ve model rocketin parentı olarak ayarladığımız empty game objectimizin 
inspectorunda script altında Thrust değişkenini görüyoruz. O değişkenin yanında "+" işareti var, burası "bindings" kısmından sorumlu.

- The binding is basically saying what is the key press or button thing or the direction of the controller that you want me to bind to this particular variable.

- Binding'i temsil eden +'ya tıkladıktan sonra "Add Binding" diyoruz. Altında "<No Binding>" yazan bir yer açılıyor. Buraya çift tıkladıktan sonra "Path" kısmından neyle bağlayacağın kısmına burada karar veriyorsun. Burada keyboard,
Mouse, joystick, pointer, pen, sensor... gibi bir çok seçenek var. Biz "space" tuşunu thrust olarak kullanacağımız için Keyboard'dan space'i seçiyoruz. Seçeceğin şeyi bulamazsan Path kısmına tıklayınca Listen var,
burası senin keyboardda basacağın tuşu dinliyor, buna tıkladıktan sonra space'e basarsan da istediğin sonucu elde edersin. Burada space'e ek olarak, Game Pad'den Right Trigger kısmını da ekliyoruz.

- Bu ayarlamaları yaptıktan sonra kontrol etmemiz gerekiyor. 
	1- Create an if statement to print something when we are pressing the space key
	2- In Update(), check if thrust.IsPressed() is true.
	3- If it is true, print smt to the console

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    void OnEnable()
    {
        thrust.Enable();
    }
    void Update()
    {
        if (thrust.IsPressed())
        {
            Debug.Log("THRUST!!!");
        }
    }
}

- Bir objecti oyun içinde hareket ettirmenin 2 yolu var, ya Transform altındaki position değerlerini değiştireceksin ya da Unity Physics system kullanacaksın, yani biraz kuvvet uygulayacaksın ve
fizik sistemi geri kalan her şeyi halledecek. Burada gravity felan da devreye girmesi gerektiği için önce rigidbody eklememiz gerekiyor. Parent game objectimize, Player Rocket diye adlandırdığımız,
add component kısmından rigidbody ekliyoruz ancak bunu ekledikten sonra oyunu calıstırdıgımızda rocket aşağı tarafa doğru gitmeye başlıyor çünkü collider yok. BoxCollider'ı da eklememiz gerekiyor.
Burada boxCollider'ın center ve size değerlerini objectimizi kaplayacak şekilde ayarlıyoruz. Tıklayınca bu sefer üzerinde durduğu Launching Pad'in içinden geçip ground'un üzerinde kaldı. Bunun için
Launchin Pad'e de collider eklememiz gerekiyor.

- Imported assetlerle ilgili önemli bir detay var, if we import an fbx model we can drop it into our scene however we like. Scale it, rotate it... However we cant alter the original model file, we cant alter
the FBX file itself thats why, we cant "apply back to prefab". If we use one of these models from our scene to create a prefab, it will create a "prefab variant". Changes made to one Prefab Variant Instance will be
applied to other instances, but not the original artwork.

- Prefab Variant oluşturmak için de önce asset folderında önceki projede yaptığımız gibi Prefab folderı oluşturuyoruz. Launching ve Landing pad'leri import ettiğimiz modelleri sürükleyip bırakarak yapmıştık ancak burada
landing pad'i kaldırıyoruz. Launching pad'i prefab folderına sürükleyerek "prefab variant" haline getirdik. Bu aslında bir şeyin kopyasının kopyası gibi. Artık burada aynen prefablerdeki instancelara yaptığımız "apply all"
seçeneğini kullanabileceğiz.

- Prefab variant'ı landing pad olarak scene'e ekledik. Collider'ı içinde geldi.

- Rocketimize rigidbody ekledik, bunu kod dosyamızda da tanımlayıp, buna erişmemiz gerekiyor. "RigidBody rb;" şeklinde tanımlıyoruz.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    Rigidbody rb;
    void OnEnable()
    {
        thrust.Enable();
    }
    void Update()
    {
        if (thrust.IsPressed())
        {
            Debug.Log("THRUST!!!");
        }
    }
}

-
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
    }
    void Update()
    {
        if (thrust.IsPressed())
        {
            Debug.Log("THRUST!!!");
        }
    }
}

RigidBody'nin componentlerini "rb" değişkenine atadık. Buradan sonra da Update içinde force uygulamamız gerekiyor ancak buradaki update, FixedUpdate() metodu.
Bunu unity dokümantasyonundaki order of execution'daki "Physics" kısmının en başındaki fonksiyon olarak göreceksin. Update fonksiyonu ise Game Logic kısmında.

- Burada dikkat etmen gereken nokta eğer Update() ve FixedUpdate() fonksiyonlarında ayrı ayrı fiziksel işler yaparsan işleri kontrolden çıkarırsın, kameranın 
titremesini görürsün. Bundan dolayı kod dosyamızda tanımladığımız Update metodunun adını FixedUpdate olarak değiştiriyoruz.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
    }
    private void FixedUpdate()
    {
        if (thrust.IsPressed())
        {
            Debug.Log("THRUST!!!");
        }
    }
}

- Burada local ve global positionlara dikkat etmen gerekiyor. Global positionlar, scene'de sağ üstteki koordinat düzleminin gösterdiği poisitionlar ve asla değişmezler. Yani sen eğer globalde
y ekseninde force uygularsan y'de ilerleyecek ancak diyelim ki rocketini 45 derece saat yönünde yatırdın ve global positiondayken yine force uyguladın o zaman 45 açıyla ilerlemen gerekirken yine dikey kalkış
yaparsın ki bu da roket mantığına aykırı. Local position kullandığında ise, roketi 45 derece saat yönünde yatırırsan eksenler de , y ekseni de 45 derece saat yönünde yatacak ve thrusterlar calıstıgında roket
45 derece saat yönünde ilerleyecek.

- Burada ekleyeceğimiz force fonksiyonu, addrelativeforce olacak çünkü bu force local positionlar ile alakalı.

- Rigidbody componentindeki mass ile oynayabilirsin.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
    }
    private void FixedUpdate()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(100,0,0);
        }
    }
}

- rb.AddRelativeForce(0,10,0); bu kod bloğu bizim objecti yukarı taşımak için gereken kod bloğu, aynı işi rb.AddRelativeForce(Vector3.up); ile de yapabiliriz.

- Burada yapacağımız birkaç işlem kaldı. Vector3.up 'ın karşılığı (0,1,0). Bunu güçlendirmemiz için thrustStrength değişkeni oluşturacağız, sonrasında da bunu
frame rate independent yapmamız lazım. Önceki projede Update metodu içindeyken Time.deltaTime kullanmıştık ancak burada FixedUpdate içindeyiz, bundan dolayı
Time.fixedDeltaTime kullanacağız.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] int thrustStrength = 100;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
    }
    private void FixedUpdate()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
        }
    }
}

Burada Time.fixedDeltaTime'dan dolayı rocket çok çok az ilerliyor çünkü bu değer bayağı küçük. Bundan dolayı strength'i çok yüksek bir değere çekmemiz lazım.

- Şimdi de rotation binding yapacağız, sağ ok tusu bize 1 değerini verirken sol ok tusu bize -1 değerini verecek.

- Şimdi movement scripti içinde InputAction tipinde bir SerializeField olarak bir rotation değişkeni tanımlayacağız sonrasında da bunu OnEnable fonksiyonu içinde
enable haline getireceğiz. Sonrasında da unity arayüzüne gelince sağda inspector altındaki script altında değişkeni göreceğiz. Burada +'ya tıklayarak binding yapacağız
ancak ilkinde yaptığımız gibi add binding değil, burada negatif ve pozitif değerler de işin içine gireceği için seçimi ona göre yapacağız. Burada seçeceğimiz kısım "Add positive/negative binding"
Sonrasında eklenen yerde negative binding kısmına keyboard -> left arrow 'u atarken, positive binding kısmına keyboard -> right arrow kısmını atacağız. Rotation altındaki "1D Axis" yazan 
ve keyboard ayarının oldugu yerdeki bu "1D Axis" yazısını değiştirip istediğini yazabilirsin, buraya Keyboard yazdık. Burada aynı şekilde, rotation'a bir de gamepad için ekleme yapacağız. 
Burada gamepad kısmından negatif ayarını left stick/left olarak değiştirip, sağ ayarını da right stick/right olarak değiştireceğiz.

- Burada yazacağımız kodda if (rotation.IsPressed()) tarzında bir şey kullanamayız çünkü rotation'ın negatif ve pozitif değerlerine ayrı ayrı tuş tanımladık. Burada yapacağımız
şey "ReadValue<float>"  kullanmak, çünkü bastığımız ok tuşlarından okuyacağımız değer ya pozitif olacak ne ya negatif olacak. Buradan bir değer döndüreceği için bunu da bir değişkene
atamamız gerekecek.

- "ReadValue<float>" bu şekilde yazsak bile burada ya 1 ya da -1 değeri dönüyor.

- Burada sonraki aşama, bu zamana kadar script, rigid body ve collider eklediğimiz roketin parent objectini yani Player Rocket'ı Prefab folderının içine atıp Prefab Variant
durumuna getiriyoruz.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 100;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        Debug.Log("Rotation : " + rotationInput);
    }
}
   
- Buraya şimdi de şunu ekleyeceğiz, eğer rotation değeri pozitif ise sağa rotate et, negatifse sola rotate et

- 
private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            transform.Rotate(0f, 0f, 1f);
        }
    }

Buradaki rotate kısmında koordinatları Vector3 ile de yazabiliriz.

private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            transform.Rotate(Vector3.forward);
        }
    }

Burada Mouse ile "forward" yazısı üzerine geldiğimizde bize (0,0,1)'e eşit olduğunu söylüyor.Oyunu çalıştırdıgında pozitif value'nun oyunda
sola rotate ettirdiğini görüyorsun, bundan dolayı transform.Rotate(Vector3.forward); kod satırını transform.Rotate(Vector3.back); olarak değiştireceksin,
bu da bize (0,0,-1) değerini verecek. Ya da bunun diğer bir yolu ise transform.Rotate(-Vector3.forward); yazmak yani Vector3 değerinin başına minus sign
koymak.

- İki tane if condition'ı alt alta yazmak bu case için sıkıntılı, ya aynı anda hem negatif hem pozitif değer gelirse ne olacak. Bundan dolayı if-elseif yapısını
burada kullan.

- Şimdi rotation'ı frame rate independent yapacagız ancak Time.fixedDeltaTime değeri çok çok küçük oldugu için, thrust'a yaptıgımız gibi rotationStrength adında bir değişken
tanımlayıp onu kullanacagız. 

-
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 1000;
    [SerializeField] float rotationStrength = 1000f;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            transform.Rotate(Vector3.back * rotationStrength * Time.fixedDeltaTime); // transform.Rotate(-Vector3.forward);
        }
        else if (rotationInput < 0)
        {
            ApplyRotation(rotationStrength);
        }
    }
    private void ApplyRotation(float rotationThisFrame)
    {
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
    }
}
Burada methodları parametrelerle tanımlamayı görüyoruz. RotationInput'ın pozitif olduğu durumda da ApplyRotation(-rotationStrength) yazacağız. Normalde minus sign ı Vector3 önüne koymuştuk ancak
çarpım durumunda olduğu için nerede olacağının cok bir önemi yok.

-
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 1000;
    [SerializeField] float rotationStrength = 1000f;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            // transform.Rotate(Vector3.back * rotationStrength * Time.fixedDeltaTime); 
            // transform.Rotate(-Vector3.forward);
            ApplyRotation(-rotationStrength);     
        }
        else if (rotationInput < 0)
        {
            ApplyRotation(rotationStrength);
        }
    }
    private void ApplyRotation(float rotationThisFrame)
    {
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
    }
}

- Şimdi de rocketi takip edecek bir cinemachine camera eklememiz gerekecek.

- Window -> Package Manager ve buradan da cinemachine kamerayı ekle ve hierarchy içinde de "cinemachine camera"yı ekle.
Sonrasında da Main Camera'ya tıkla ve sağda inspector altında "cinemachine camera brain"'in eklenip eklenmediğini kontrol et.

- Hierarchy altındaki "Cinemachine Camera"'ya tıkla ve sonrasında da sağda "Tracking Target"'ı Rocketin parent objecti yap. Sonrasında biraz altında 
"Procedural Component" kısmındaki Position Control, Rotation Control değerlerini ayarlar. Position Control değerini "Follow"'a çek, Rotation Control değerini
ise "None"da bırak çünkü kameranın rotate edeceği bir oyun değil. Sonrasında da alt tarafta Position Control'u Follow yaptıktan sonra açılmış olan "Cinemachine Follow"
kısmından da Follow Offset ayarlarını ayarlayarak kameranın konumunu netleştir.

- Yukarıda Game sekmesi altında "Free Aspect" ayarından ekran ratiolarını ayarlayabilirsin.

- Şimdi de Rotation Control kısmını "Spline Dolly Look At Targets" olarak değiştiriyoruz.

- Burada dikkat edersen, oyun ve kamera titriyor, bunun sebebi de daha öncesinde belirttiğimiz gibi Update metodu. Bu sorunu çözmek için
Main Camera objectine geliyoruz, Altta "Cinemachine Brain" altında "Update Method" var. Burası "Smart Update" olarak ayarlanmış ancak bunu "FixedUpdate"'e çekiyoruz.

- 















































