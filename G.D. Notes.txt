
- Unity yüklerken WebGl Build Support modülünü de yükle, yaratacağın oyunun böylece web'de de oynanmasını 
sağlayabilirsin

- Unity ne işe yarar: Visual interface for creating games and systems of existing code we can use(physics,
rendering, audio)

- Unity ve VS Code'u .cs file ile birbirine bağlıyoruz. .cs dosyaları bizim vscodeda yazacağımız
script dosyaları. 

- Buradaki kodlar game engine'a ne yapılacağını söylüyor.

- Proje oluştururken unity hub içinden project->new Project oluşturuyoruz, burada Universal 3D'yi seçeceğiz. Mobil
ya da oyunun HD versiyonu için de burada seçenekler mevcut

- İlk Projeyi oluşturduktan sonra unity açılacak ve solda sample scene altında 3 tane game object çıkacak
Bunlar: main camera, directional light ve global volume

- Bu objectlerde componentler var, bunlar, ekranın sağındaki inspector altında. Her objectde olan componentlerden biri de "Transform" component, bu component bize
positionı set etmeye, rotation varsa uygulamada işimize yarayacak.

- Buradaki 3 game object'e ek olarak kendi game objectimizi nasıl yaratacağız. Oradaki boşluğa gelip sağ 
tıklayıp 3D object'den cube diyeceğiz.

- Mouse'un right click butonu ile object üzerinde kamerayı döndürerek işlem yapabiliyoruz, ve ok butonları 
ile de ekran üzerinde gidip gelebiliyoruz bunlarla point of view'u değiştirebiliyoruz.

- Object'den çıkan renkli oklar bize 3 boyutlu koordinat düzlemindeki x y z eksenlerini gösteriyor.

- Object oluşturmadan önce ekranda zaten bulunan küçük küp "global volume". Bunun "rendering" ile
alakası var ancak bu ilerleyen aşamalarda

- Object üzerinde çıkan koordinat düzlemini gösteren oklardan birinin üzerine mousela gelip basılı tutarsan
o eksende hareket ettirebilirsin

- Ekranın sağ tarafındaki "transform" kısmındaki koordinatları kullanarak da objeleri hareket ettirebilirsin

- Transform kısmında gösterilen position kısmını "W" tuşu, Rotation kısmını "E" tuşu ve Scale kısmını da
"R" tuşu kontrol ediyor. Bu şekilde istediğimiz pozisyonlarda object ile oynayabiliriz.

- R tuşuna basıp küp olan bir objeyi 3 eksende de çekip uzatabilir ya da kısaltabilirim.

- Araba'nın parçalarını ayrı ayrı object olarak ekliyoruz. Önce arabanın ana gövdesi için küp ekledik,
sonra arabanın tekerlekleri için de silindir ekledik. Bunlar solda Sample Scene içinde duruyorlar. Bu 
silindiri E tuşuna basıp rotate ettirerek yer düzlemine paralel hale getiriyoruz.

- Ekranın sol altında Assets kısmı var. Burada olan her şey bilgisayarın hard drive'ında tutuluyor.
Bizim Project directory'deki Assets kısmı ile hierarchy arasındaki en büyük fark bu. Hierarchy içinde
game objects var these are the game objects that are located and living within our sample scene and 
our sample scene is saved in the "Scenes" folder onto our hard drive.

- Simdi Assets içinde yeni bir material oluşturacağız ve adına da colour1 diyeceğiz. Colour1'a tıklayınca
sağ tarafta inspector içinde bu material'ın özellikleriyle biraz oynayacağız. Mesela burada "Base Map" denilen
yerde bu material'ın rengini ayarlıyoruz. Ayarlamayı bitirdikten sonra bu materialı sürekleyerek tasarım
yaptığımız ekrandaki objectlerden birinin üzerine bırakınca object direkt olarak renk değiştiriyor. 

- Silindir olan tekerleğin adını Wheel olarak değiştirdik sonra bunu duplicate ederek 4 tane yapıp
arabanın ana bodysi içine koordinat düzleminde oynatarak ekleyebiliyoruz.

- Sol tarafta objectleri birden fazla olacak şekilde seçip aynı oranda ekranda koordinat düzleminde
hareket ettirebilir ya da aynı oranda rotate ettirebilirsin.

- VSCode'a extension eklemeyi unutma. C#, Unity ve Unity Code Snippet'ı extensions kısmından ekle

- Unity açıldıktan sonra sol üstte Edit kısmı altındaki Preferences'a tıkladıktan sonra External Tools
altındaki External Script Editor'u VS Code olarak ayarla.

- Assets altında sağa tıklayıp create diyip sonra scripting ve C# Script'e basarak script dosyasını
Assets altında tanımlıyorsun.

- Bu script dosyasına çift tıklayınca VSCode açılacak.

- Game Design felsefesinde, Player Experience(akıllıca mı, panik mi,acele mi, dikkatli mi hissetmesini
istiyoruz.), Core Mechanic(Move & Dodge obstacles, burada oyunun ana temasının mekaniği üzerinde
duruyoruz),Game Loop(Get from A to B)

- Avoiding Obstacle(AO) projesinde önce 3D object plane yaratarak bayağı büyük bir scale a getirdik.
Sonra assets kısmına material ekledik, bunun "base map"'ine gelerek siyah yaptık ve ekrana doğru
sürükleyerek plane içine bıraktık, böylece plane siyah oldu.

- Plane'in parlaklığını yani güneş paneli gibi yansıyan siyah tarzından düz siyaha geçmesini
istersek o zaman sağ tarafta base map altında smoothness var, onu azaltman lazım.

- Assets altında folder yani directory oluşturup materiallerin hepsini oraya atabilirsin, böylece
oyun dosyalarını daha modüler hale getirebilirsin. Folder oluştururken de assets içindeki boşlukta 
sağa tıklayarak create diyip sonra folder diyeceksin, isimlendirip sonra şimdiye kadar oluşturduğun
color materiallerini içine atacaksın.

- Sonrasında da yine assets içinde Scripts isimli başka bir dizin oluşturacaksın. Buraya script
dosyalarını atacaksın.

- Script oluştururken önce MonoBehaviourScript oluşturduk bu file which is the standard
unity starting point script. Herhangi bir dosya oluştururken ismini yazmadan önce 
herhangi bir yere tıklarsan bir daha onu değiştiremezsin o yüzden önce ismini yaz.

- Oluşturdugumuz scripte "Mover" adını vererek bıraktık.

- Oluşturulan script dosyalarını bir object ile bağlamamız gerekiyor. O script dosyasında 
yazanlar o object'i kontrol edecek ve hareketlerini belirleyecek. Script dosyasını object ile 
bağlamak için script dosyasına basılı tutarak solda Sample Scene altındaki bağlamak istediğimiz
object'e sürüklüyoruz ya da object'e tıklayınca sağda açılan inspector altındaki "Add component" 
kısmına gelerek oradan script dosyasının adını aratıp oradan ekleyebiliyoruz.

- Sonrasında script dosyasına çift tıklayınca vscode açılacak.

- Unity'nin başlangıç noktası olan scriptinde start ve update metodları var. Unity'de 
start butonuna bastığımızda player'ın bütün componentleri aktif hale gelecek.

- 
void Start()
    {
        transform.Translate();
    }
burada yazdıgığımız transform, unity içinde object'e tıklayınca sağda gördüğümüz
Transform componentini temsil ediyor. Burada metodları kullanarak transform altındaki
position, rotation ya da scale değerlerini manipüle edebiliriz.

- Translate içinde hangi koordinat ekseninde ne kadar hızlı gitmek istediğini belirtiyorsun

- Yukarıda "Scene" yanında bir de yanında konsol işareti bulunan "Game" sekmesi var. Bu sekme
oyunun oynanacağı zaman kullanıcı gözünden nasıl görüleceğini gösteriyor. Onu da sürükleyerek
Scene'in sağ tarafına bırakıp hem geliştirdiğimiz şeyi hem de oyuncu tarafından görülen kısmını
aynı anda görüyoruz.

- Sol tarafta bulunan main camera objecti, kullanıcının player'a nereden bakacağını belirtmemizi
sağlıyor.

- Main camerayı da ayarladıktan sonra play butonuna tıklayınca 

void Start()
    {
        transform.Translate(1,0,0);
    }

kodu sayesinde player objecti x ekseninde 1 birim sağa gidiyor. Eğer stop
butonuna basarsan object başlangıç noktasına geri geliyor.

- Frame is every time our game calculates what should be happening in
our World.

- Buradaki kullanımda "frame", ekranın bir kez güncellenmesini ifade eder. Bilgisayar oyunlarında ya da gerçek zamanlı simülasyonlarda saniyede kaç kez ekranın yenilendiğini belirtmek için kullanılır.
FPS (Frames Per Second): Saniyede kaç frame işlendiğini gösterir. Örneğin 60 FPS, saniyede 60 kez ekranın yenilendiği anlamına gelir.

- Bir animasyonun içindeki her bir poz da "frame" olarak adlandırılır. Örneğin bir yürüyüş animasyonu 30 kareden oluşuyorsa, 
bu 30 frame’de karakterin adım adım hareketi gösterilir.

- Eğer bu satırı , transform.Translate(1,0,0) , update metodu içinde yazarsak
o zaman frame hesabı işin içine girecek. Saniyede 60 frame işliyorsa o zaman
bir saniye içerisinde yukarıdaki kod, objecti x ekseninde 60 birim ilerletecek.

- transform.Translate(0.01,0,0); yazarsan hata alırsın double'ı float'a çevirmen
gerekiyor bunun için de  transform.Translate(0.01f,0f,0f); yazman lazım.

- C# da integer bir data tanımlarken int hitPoint = 20; diyerek tanımlıyoruz, ya da
float tanımlamak istediğimizde float speed = 3.8f; 
Boolean tanımlamak istediğimizde bool isAlive = True; 
String tanımlamak istediğimizde string myName = "yusuf";

- Oyun içinde kullanacağımız değişkenleri tanımlayacağımız zaman start metodu üstünde ve
Public Class Mover : MonoBehavior altında tanımlıyoruz.

-
using UnityEngine;

public class Mover : MonoBehaviour
{
    float xValue = 0.01f;

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        transform.Translate(xValue,0f,0f);
    }
}

- Object'ini hareket ettirmek istediğin koordinata unity arayüzündeki oklardan bakabilirsin.

- Bir değişiklik yapıp play butonuna her bastığımızda Sceneleri ve domainleri yüklüyor, bu da 
zaman kaybı. Statik değişkenlerle uğraştığımız durumlarda bunu yapmamıza gerek yok. Ancak ilerleyen
zamanlarda eger bir şeylerin ters gittiğini ya da hata aldığını görürsen o zaman tekrar eski haline
getirebilirsin. Edit altında Project settings kısmına geleceksin. Orada Editor'e tıklayıp
en alta ineceksin. "Enter Play Mode Settings" kısmının ayarlarını değiştireceksin. Do not reload domain 
or scene olanı seçeceksin.

- Start metodu üstünde tanımladığın değişkenleri [SerializeField] float yValue = 0.01f; bu şekilde
tanımlarsan o zaman bu değişkeni unity içinde görebiliyor ve değişkenin değerini unity içinde değiştirebiliyor
oluyorsun. Bu script dosyasını bağladığın object'in ekranın sağ tarafındaki inspectorda bu değişkeni 
görüyorsun. Sağ taraftaki Mover scriptinin altında "Y values" yazıyor. Bu sayede original script kodu içinde
herhangi bir değişiklik yapmadan sadece unity arayüzünde değişkenleri test edebiliyorsun. Buna da SerializingField
deniyor.

- SerializeField olarak tanımladığın değişkenleri unity içinde Mouse'unla üzerine basılı tutup sağa sola 
oynatarak da değerlerini değiştirebilirsin ancak koddaki değer değişmez. 

- Oyuna "Simple Movement" özelliği katabilmek için birçok yol var. Biri Input System, diğeri position
of object(bunu ya manuel olarak change location yapıyoruz ya da force uyguluyoruz. Force uyguladığın durumda unity'nin
fizik kısmını kullanıyoruz.)

- Unity 6 ile birlikte yeni bir input sistemi devreye aldılar ancak bu projede eski input sistemini 
kullanacağım. Edit->Project Settings->Solda Player'a tıkla ve sağdaki geniş kısımda Other Settings kısmını
expand et ve alta yakın bir yerde "Active Input Handling" denilen bir kısım var. Burayı "Input System Package Old"'a çek.

- Aynı şekilde Project Settings altında "Input Manager" kısmı var. Burada axislerle ilgili ayarlamaları yapabiliyoruz, yani
hangi tuşları hangi eksenlere assign edeceğimizi burada belirtiyoruz. Burada horizontal sağ ve sol u kastediyor. Alternative Negative 
Button derken solu, Alternative Positive Button derken de sağı kastediyor. Aynı şekilde vertical kısmında da tuşlar zaten tanımlanmış
durumda ancak değiştirmek istediğinde ayarlamaları buradan yapıyorsun.

- Update metodu içinde değişkenleri SerializeField olarak tanımlayamıyoruz çünkü zaten burada dynamic olarak kontrol ediyoruz değişkenleri.

- 
void Update()
    {
        float xValue = Input.GetAxis("Horizontal");
        float yValue = 0f;
        float zValue = 0f;
        transform.Translate(xValue,yValue,zValue);
    }

Burada x değerini keyborddan sağ ve sol ok tuşlarına basarak ayarlacağımız kodu yazdık. Burada string olarak belirttiğin
ifadeye dikkat et, eğer horizontal eksende ilerleteceksen aynen bu şekilde yazman lazım yoksa kodun çalışmaz. Bunu yazdıktan sonra
unity'de play butonuna bastıgında ok tuşlarıyla objectini horizontal eksende pozitif ve negatif yönde ilerletebiliyorsun.
Dikey eksende ilerletmek için de ikinci satırı float yValue = Input.GetAxis("Vertical"); şeklinde güncelliyorum.

- Buradan çıkan diğer sorun ok tuşlarını kullandıgımızda object çok hızlı bir şekilde hareket ediyor, bu hareket
hızını ayarlamamız gerekecek. Bunu da Time.deltatime kullanarak yapacagız.

- Unity'de Scene sekmesinin yanındaki Game içinde "Stat" adında bir sekme daha var. Oraya tıklarsan oyun esnasındaki FPS ve CPU ile
ilgili değerleri anlık olarak göreceksin. Burada ayarlamak istediğimi kısım frame rate. Burası bilgisayardan bilgisayara değişen
bir değer. Bunu consistent hale getirmek oyun ve oyuncular için önemli.

- Using Time.deltaTime Unity can tell us how long each frame took to execute

- When we multiply something by Time.deltaTime, it makes our game "frame rate independent" which means
the game behaves the same on fast and slow computers.

- Input.GetAxis("Horizontal") burası bize -1 ile 1 arasında değer döndürüyor.

- 
 void Update()
    {
        float xValue = Input.GetAxis("Horizontal") * Time.deltaTime;
        float yValue = Input.GetAxis("Vertical") * Time.deltaTime;
        float zValue = 0f;
        transform.Translate(xValue,yValue,zValue);
    }

artık frame rate independent hale getirdik. Eğer objectin bu halindeki hızı yavaş ya da yine de hızlı
bulduysan o zaman bir değer ile çarp. Örnek olarak
 float xValue = Input.GetAxis("Horizontal") * Time.deltaTime * 2;

-
using UnityEngine;

public class Mover : MonoBehaviour
{
    [SerializeField] int moveSpeed = 10;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        float xValue = Input.GetAxis("Horizontal") * Time.deltaTime * moveSpeed;
        float yValue = Input.GetAxis("Vertical") * Time.deltaTime * moveSpeed;
        float zValue = 0f;
        transform.Translate(xValue,yValue,zValue);
    }
}

- Player ya da yarattığımız object hareket ederken cameranın da onunla birlikte hareket etmesini
istiyorsak cinemachine'ı entegre edeceğiz.

- Cinemachine is a unity package. Birden fazla camerayı scene içinde kontrol edebilmemizi sağlıyor,
camera için kurallar koymamızı sağlıyor

- There is a few different aspects of cinemachine. First of all, we have a "cinemachine brain" which sits
right on top of our main camera. It figures out what the player should see and then we can have a number 
of virtual cameras that feed into the brain. Burada brain kararları veriyor, camera2 sıra sende, ya da 1. kamera
artık sendeyiz gibisinden. Ancak bu oyun özelinde sadece bir tane virtual camera kullanacağız yani kameralar 
arasında gidip gelmeyeceğiz.

- Önce package manager'dan cinemachine'ı yükleyeceğiz. Sonra virtual kamera ekleyeceğiz sonrasında da 
we will make sure Cinemachine Brain component has been added to Main Camera and point the virtual camera 
to follow the player and then tune distance, rotation, damping.

- Package Manager'a yukarıda "Window" kısmından erişiyorsun. Sekme açıldıktan sonra solda "Unity Registry"'e tıkla 
Burada ulaşabileceğin bütün packageları görüyorsun. Buradan Cinemachine'ı yükle.

- Paketin yüklenip yüklenmediğini kontrol etmek istiyorsan sol altta Project altında Packages kısmını genişlet 
ve alttaki paketlere bak

- Solda Hierarchy'deki boşluğa yani sample scene altındaki boşluğa sağ tıklayınca altta Cinemachine'i göreceksin, 
cinemachine yanında açılan kısımdan da cinemachinecameraya tıklayarak ekle.

- Main camera objectine tıklayınca sağda inspector altında Cinemachine brain'i göreceksin.

- Cinemachine kameranın player objectimizi sürekli takip etmesini istiyorsak, cinemachine cameraya tıklayıp
sağdaki inspector altında "Tracking Target" kısmında takip etmesini istediğimiz objecti seçeceğiz.

- Kameranın duruş şekillerini cinamachine cameranın inspector'unda Procedural Component altındaki
position control ile kontrol ediyoruz. "Hard lock to target" seçeneği kamerayı objectin tam üstüne yerleştirirken,
"third person follow" seçeneği ise kamerayı tam arkasına yerleştiriyor. 

- Rotation control kısmını da "hard look at" seçeneğine çektiğimizde, bu kısım kameraya nerede olursan ol 
playera bak ancak bunu rotation point of view'dan yap diyoruz. Bunu ayarladıktan sonra cinemachine kamerayı
üzerindeki koordinat sistemini gösteren okları kullanarak hareket ettiremiyorum, bunu çözmenin yolu da 
yine inspector altında cinemachine follow kısmında "follow offset" ayarının Y değerini manuel olarak değiştirmek.

- "Cinemachine camera hard look at" kısmındaki "look at offset" değeri ise playerın tam üstünü hedef almanı değiştiriyor.
Bunu player üzerinde olan sarı kareden anlayabilirsin. Buradaki offset değerlerini değiştirerek kamerayı player'ın biraz
üstüne ya da altına odaklamak mümkün.

- "Cinemachine Follow" kısmındaki "follow offset" değerini değiştirdiğinde, objectin üzerindeki sarı kare sabit 
kalacak şekilde ya daha yukarıdan bakıyorsun ya daha sağdan bakıyorsun gibi ayarlamaları yapıyorsun ancak "Cinemachine
Hard Look At" altındaki "Look at offset" değeri ise cameranın odağını değiştiriyor yani object üzerindeki sarı kareyi değiştiriyor.

- Burada Procedural Component altındaki Position Control ve Rotation Control kısımlarında seçtiğin seçeneklere göre aşağıda
kamera ayarlama seçenekleri açılacak. Position Control'ı Follow olarak ayarlarsan aşağıda Cinemachine Follow açılacak ve oradan
Follow Offset ayarlarını ayarlayabileceksin.

- Rotation Control kısmında Hard Look At seçeneğini seçmen durumunda altta çıkan ayarlardan Cinemachine Hard Look At kısmında
Look at Offset değeri kameranın bulunduğu yer sabit kalacak şekilde baktığı yerin rotational ayarının yapılmasını sağlıyor.

- Bütün bu ayarlamaları yaptıktan sonra oyunu başlattığımızda kamera objectin hareketlerini biraz gecikmeli olarak
takip ediyor, bunun ayarlamasını da "damping" kısmından yapacağız.

- Position damping kısmındaki X değerini 0 yaparsan, object x ekseninde hareket ederken kamera da onu herhangi bir gecikme
yaşamadan takip eder. Buradaki değerlerle eksenlerdeki kamera hareketlerinin gecikmeli olup olmamasını kontrol edebiliyorsun

- Duvar eklemek istediğin zaman cube olarak object ekle ve onu scale ederek istediğin duvar boyutuna getirebilirsin.

- Herhangi bir objectin inspectorı altındaki "Transform" yazısına sağ tıklayıp reset dersen tam ortaya alıyor ve
scale boyutlarını da 1'e çekiyor. 

- Hierarchy içinde "empty game object" oluşturup bunun da Transform değerlerini sıfırladık. Sonra 4 walls objectini ve 4 obstacle
objectini bu oluşturduğumuz ve Environment adını verdiğimiz empty objectin üstüne sürükleyerek bu objectin altında 
gruplandırdık. Bu şekilde modülerliği ve dosyalar üzerindeki kontrolünü artırıyorsun.

- Oyunu çalıştırdığımızda ana objectimiz duvarların ve engellerin içinden geçiyor ancak bunlara çarpmasını istiyoruz.
Burada colliders'lar devreye girecek.

- Player objectinin inspectorunda mesh renderer kısmı checked halinde. Bunu kapatırsak ana objectimizin(cube) yüzeylerini
kaplayan turkuaz rengi duvarlar gidecek sadece Box Collider kalacak. Bu da yeşil olarak gösterilen ve küpün iskeleti.

- Çarpışma olabilmesi için sistemin fizik kurallarına uyması lazım. Bunun için de player'ın yani ana objectin bir mass 
kazamnası lazım. Ana objectin inspectorunda en altta "add component" kısmına gelerek orada "rigid body" ekliyoruz.

- Rigid body içinde mass, linear damping, angular damping ve gravity gibi fiziksel değerler var. Bu objecti dikeyde 
kaldırıp oyunu başlatırsak gravity etkisiyle yere düşecek.

- Artık duvarlardan ya da engellerden geçemiyor ancak engelden geçmeye zorladığında bir titreşim hareketi ve bazen de 
bounce back yapıyor. Bunu engellemek, yani direkt olarak duvarın ya da engelin oraya gelince durmasını sağlamak için
constraint eklememiz gerekiyor, bunu da rigid body içindeki constraints'den yapıyoruz.

- Constraints içinde duvarla collisin durumunda rotational şekilde bounce back hareketini önlemek için rotation kısmındaki
bütün eksenleri donduruyoruz. Yüzeyde de x ve z ekseninde ilerlediğimiz için herhangi bir collisin durumunda y eksenindeki 
hareketlerin de durmasını istiyoruz. Bundan dolayı constraint altındaki freeze position kısmından da y'yi checked durumuna
getiriyoruz.

- Eğer oyundaki bir objectinin inspectorunda box collider yoksa ya da ona hangi collider türü uygunsa ve o collider türü
yoksa o zaman ana object onun içinden geçebilir.

- Bir objectin box collider'ı içinde edit collider'ı actif hale getirirsek object üzerinde yeşil noktalar göreceksin
Bu noktaları çekip uzatarak object ile collide edeceği yeri mesh'inden farklı konuma getirebilirsin.

- Box collider içinde isTrigger kutucuğu var. Bunu checked hale getirirsen object ile collide etmiyor, yani içinden 
geçiyor ancak içinden geçtiğinde bir şeyler triggered hale geliyor. Kapıdan geçince karşısına canavar çıkan bir 
oyun tasarlayacağımız zaman kapıdan geçtiğinin kontrolünü isTrigger ile yapıyoruz. Bu bizim koda bir mesaj gönderecek,
biz de kapıdan geçince ne olacağını kod bloğunda yazmış olacağız ve orası çalışacak.

- Bir object'in "mesh renderer" kısmındaki kutucuğu kapatırsan sen development kısmında bunun iskeletini görebilirsin ancak
oyuncu bunu göremez. Bunu kapatıp isTrigger seçeneği işaretlenirse oyuncu rastgele geçtiği bir yer sonucunda başına geleceği
kod dosyanda ayarlayabilirsin. Bir kapıdan geçince karşısına canavar çıkması gibi...

- 
void PrintInstructions()
    {
        Debug.Log('Welcome to the game!');
    }
Bu kod bloğunun yapacağı şey unity içindeki console'da görünecek. Bu metodun console'da bir kere 
görünmesini istiyorsam start() metodu içinde çağıracağım.

- 
using UnityEngine;

public class Mover : MonoBehaviour
{
    [SerializeField] int moveSpeed = 10;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        PrintInstructions();

    }

    // Update is called once per frame
    void Update()
    {
        MovePlayer();
    }

    void PrintInstructions()
    {
        Debug.Log("Welcome to the game!");
    }

    void MovePlayer()
    {
        float xValue = Input.GetAxis("Horizontal") * Time.deltaTime * moveSpeed;
        float yValue = Input.GetAxis("Vertical") * Time.deltaTime * moveSpeed;
        float zValue = 0f;
        transform.Translate(xValue,yValue,zValue);
    }


}

Bu işlemlerin metodlar altında bu şekilde yapılması ve gerektiğinde o metodların çağrılması
kodun daha modüler ve üzerinde daha cok kontrol sahibi olmamızı sağlıyor

- Şimdi de oyun içindeki engellere ya da duvara çarpınca console'da uyarı verdirten bir script 
yazacağız. Önce "ObjectHit" isminde bir script oluşturup bunu environmenttaki bütün obstacle ve 
wallara bağlayacağız. Burada da oluşturacağımız script tipi monobehaviourscript.

- Birden fazla object'e aynı scripti bağlarken objectlere ctrlye basılı tutarken tıkla ve sonra 
sağ altta add component kısmından script adını yani ObjectHit'i arat ve ekle.

- Buradaki script dosyasını açtıktan sonra start ve update metodlarını silebilirsin. Bunlarla işimiz
yok. Bunun yerine onCollisionEnter metodunu yazman lazım.

- 
void OnCollisionEnter(Collision collision)
    {
        
    }
buradaki metodda şimdilik parametreye ihtiyacımız yok, çünkü sadece çarpma bilgisini toplayacağız ancak
kimin obstacle'a ya da Wall'a çarptığını öğrenmek istiyorsak o zaman işte buradaki parametre işimize 
yarayacak.

- 
using UnityEngine;

public class ObecjtHit : MonoBehaviour
{
     void OnCollisionEnter(Collision collision)
    {
        Debug.Log("Something hit me!!!");
    }
}

Bunu yazdıktan sonra oyunu başlattığımızda duvara carptıgımızda bu mesajı görüyoruz ancak duvara
çarpma yönündeki oka basılı tuttuğumuzda bu mesaj yüzlerce kez consoleda yazdırılmıyor.
Eğer objecti duvardan biraz uzaklaştırıp tekrar çarparsak o zaman yine bu mesajı görüyoruz.

- Şimdi de ana object bir yere carptıgında o çarptığı object renk değiştirsin istiyoruz. Bunu nasıl
yapacağız ? Öncelikli olarak bir objectin componentlerine bakacağız. Mesh renderer, box collider ve script var.
Eğer bir objecte script bağlı ise o scripti kullanarak  componentler hakkında bilgi çekebiliriz. Mesela duvarın mesh renderer'ının altında
material kısmı var orada da blue kısmı var. Duvara script bağlı olduğu için, burayı script üzerinden değiştirebiliriz.

- 
 void OnCollisionEnter(Collision collision)
    {
        GetComponent<MeshRenderer>().material.color = Color.red;
        Debug.Log("Something hit me!!!");
    }

GetComponent<MeshRenderer>().material.color = Color.red; bu kod satırı mesh renderer
componentini al ve onun material altındaki color'ını değiştir diyor. Burada GetComponent
keyword'üne dikkat et, bunu cok kullanacaksın.

- Şimdi de player'ın çarpma sayısını console'da yazdırmak istiyoruz ya da diğer bir deyişle
score tutmak istiyoruz. Bunun için önce Scorer diye bir script oluşturup ana objectimize bağlıyoruz.
Sonrasında da içinde onCollisionEnter metodunu oluşturuyoruz ve çarpma sayısını integer değer ile orada
tutuyoruz.

using UnityEngine;

public class Scorer : MonoBehaviour
{
    int Score = 0;
    void OnCollisionEnter(Collision collision)
    {
        Score++;
        Debug.Log("You bumped into this many times: "+ Score );
    }
}
Her çarpmada fonksiyon tetiklenecek ve score değişkeni bir artacak ve onu da console'da yazdıracak.


- Burada dikkat et, player objectine yani ana object'e iki tane script bağlı biri Mover, diğeri de 
Scorer. Mover içinde ana fonksiyonlar olan start ve update var, Scorer içinde ise çarpışmayı
anlayacak fonksiyon ancak ikisi de aynı anda çalışabiliyor.

- Rotate ederken E tuşuna basıyorduk, eğer E tuşuna basıp rotate modunu açıp sonra control tuşuna basılı
tutarak rotate edersen o zaman açılı olarak rotate edebiliyorsun.

- transform.Rotate(2,3,4); bu kod scriptini bağladığın objectin rotate etmesini sağlıyor.

- Project Settings -> Player kısmından Active Input Handling'i "old ya da both" kısmına çekmezsen update metodu
içinde tanımladığın float x = Input.GetAxis("Horizontal"); satırı hata verdiriyor. Bu kod eski sisteme ait.

- Empty game object oluşturup oyundaki duvarlar ve engelleri bunun altına koyarsan, o game objecti hareket ettirdiğin
anda altındaki bütün objectler aynı oranda hareket edecek.

- Box Collider checked halde olsa bile "is Trigger" checked durumunda ise herhangi bir collision olmayacak,
ana object içinden geçecek ancak içinden geçtiği anda kodda bir uyarı göreceğiz.

- Console'a yazdırdıklarını sadece developer görebilir, PS kullanıcıs yazdığın oyunda console'da olanı göremez. 
Bu kısmı oyunu cogunlukla debug etmek istediğimizde kullanıyoruz.

- 
using UnityEngine;

public class ObjectHit : MonoBehaviour
{

    void OnCollisionEnter(Collision collision)
    {
        GetComponent<MeshRenderer>().material.color = Color.red; 
        Debug.Log("Collision happened!");
    }

}
Çarpışma olduğunda bu scriptin bağlı olduğu objectin Componentlerinden MeshRenderer içindeki materialın color'ını kırmızı 
yap.


- Time.time entegre edeceğiz, bu şekilde bizim game object oyunun başından beri ne kadar zaman geçtiğini bilecek

- Şimdi burada dropping object oluşturacağız. Bu objecti oluşturup iyice havaya kaldırıyoruz. Burada dikkat et ,
objectin gölgesi ground'a düşüyor. Bu durum oyundaki "directional light" ile alakalı. Directional light objectine tıklayıp
x, y ya da z eksenlerinde hareket ettirirsen gölgede bir değişiklik olmuyor ama rotational bir hareket yaptırırsan gölgenin
konumunda bir değişiklik oluyor

- Burada şöyle bir şey yapmak istiyoruz, oyun başladıktan 3 saniye sonra havada asılı bıraktığımız object yere düşsün.
Bunun için de Time.time kullanacağız ve sonrasında if yapısı ile 3 saniye geçtiğini kontrol ettikten sonra 3 saniye sonra 
gravity'i tekrar enable durumuna çekeceğiz.

- Burada önce Dropper.cs scriptini oluşturduk ve Dropper objectimize bağladık sonra her bir framede console a ne kadar zaman geçtiğini göstermek 
için alttaki kodu yazdık

using UnityEngine;

public class Dropper : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        Debug.Log(Time.time);
    }
}

- 
using UnityEngine;

public class Dropper : MonoBehaviour
{
    [SerializeField] float timeToWait = 2f;
    void Start()
    {
        
    }
    void Update()
    {

        if (Time.time > timeToWait)
        {
            Debug.Log("Start falling!!!");
        }   
    }
}


- Time olayını hallettikten sonra şimdi de objectin düşebiliyor olması lazım. Bununn için de dropper objectine
rigid body componenti ekleyeceğiz. Ancak burada object düşmeden önce invisible olmasını istiyoruz, bunun için de
mesh renderer ve box collider componentlerini disabled etmemiz gerekiyor. Bunu da kodda GetComponent kullanarak 
yapacağız. Aynı şekilde gravity özelliğini de GetComponent kullanarak enabled ya da disabled yapacağız.

- GetComponent<MeshRenderer>().enabled = false;
bu kod satırını start() fonksiyonu içinde yazarak MeshRenderer özelliğini en başta disabled ediyoruz.

- MeshRenderer'ı bir değişkende tutmak istediğimizde "caching" terminolojisini kullanıyoruz.

- (Def) caching is a technique of storing frequently used data or information in memory, so that it can 
easily be accessed when needed.

- MashRenderer'ı bir değişkende tutmak istediğimizde oluşturacağımız değişkenin tipi MeshRenderer olacak. Flutter'da
object tiplerini o objectleri tanımlarken kullandığımız zamanki durum burada da aynen geçerli.

-
public class Dropper : MonoBehaviour
{
    [SerializeField] float timeToWait = 2f;
    MeshRenderer myMeshRenderer;
    void Start()
    {
        myMeshRenderer = GetComponent<MeshRenderer>();
        myMeshRenderer.enabled = false;
    }
…
Burada MeshRenderer'ın bütün içeriğini artık myMeshRenderer değişkeninde tutuyoruz


- Aynı şekilde caching i rigid body'e de uygulayacağız.

using UnityEngine;

public class Dropper : MonoBehaviour
{
    [SerializeField] float timeToWait = 2f;
    MeshRenderer myMeshRenderer;
    Rigidbody myRigidBody;
    void Start()
    {
        myMeshRenderer = GetComponent<MeshRenderer>();
        myMeshRenderer.enabled = false;
        myRigidBody = GetComponent<Rigidbody>();
        myRigidBody.useGravity = false;
    }
    void Update()
    {

        if (Time.time > timeToWait)
        {
            Debug.Log("Start falling!!!");
        }   
    }
}


- Belirli bir süre sonra visible olmasını ve yere düşmesini istiyorsak o zaman update fonksiyonu altında ve if statementı içinde
yukarıda false yaptığımız özellikleri true'ya çekmemiz gerekiyor.

using UnityEngine;

public class Dropper : MonoBehaviour
{
    [SerializeField] float timeToWait = 2f;
    MeshRenderer myMeshRenderer;
    Rigidbody myRigidBody;
    void Start()
    {
        myMeshRenderer = GetComponent<MeshRenderer>();
        myMeshRenderer.enabled = false;
        myRigidBody = GetComponent<Rigidbody>();
        myRigidBody.useGravity = false;
    }
    void Update()
    {

        if (Time.time > timeToWait)
        {
            myMeshRenderer.enabled = true;
            myRigidBody.useGravity = true;
        }   
    }
}


- Bir objectin üzerine tıklayınca sag tarafta tag kısmı var. Orası bize oyun içinde objectlerle ilgili ek bilgi vermesi için önemli. Şu an 
bütün objectler untagged şeklinde duruyor.

- Asıl player objectinin tag değerini "player" olarak değiştiriyoruz.

- Şimdi ObjectHit.cs dosyasına gelip burada şöyle bir düzenleme yapacağız. Sadece ana object sana çarparsa renk değiştir. Bunu şundan dolayı
istiyoruz, dropper objectine rigid body eklediğimiz için ground'a değdiği anda o da renk değiştiriyor. Bu durumu değiştirmemiz lazım.

- 
using UnityEngine;

public class ObjectHit : MonoBehaviour
{

    void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.tag == "Player")
        {
            GetComponent<MeshRenderer>().material.color = Color.black; 

        }        
    }

}
Bu kod bloğunda eğer collision'ı gerçekleştiren game objectin tag'i "Player" ise renk değişimi gözlensin demek istedik. Artık yukarıdan 
düşen ve ground ile çarpışan objectin rengi değişmeyecek.


- 
using UnityEngine;

public class ObjectHit : MonoBehaviour
{

    void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.tag == "Player")
        {
            GetComponent<MeshRenderer>().material.color = Color.black;
            gameObject.tag = "Hit";

        }        
    }
}
Bu kod bloğundaki şu satırla gameObject.tag = "Hit"; 
şunu demek istiyoruz, eğer ben "Player" tag'ine sahip bir object tarafından 
çarpılmışsam bu player tarafından çarptığım gameobject'ine "Hit" tagini ata. 
Burada dikkat etmen gereken asıl nokta eğer "Hit" değerini sen Unity içinde sağ taraftaki Tag bloğuna eklemezsen
o zaman kodda hata alıyorsun. "Hit" değerine sağda bulunan tagler arasına ekle
ondan sonra kodda düzenlemelerini yap

- Şimdi de daha önce çarptığım bir objecte bir daha çarpmam durumunda scoreKeeper'ın tekrar artmasını
istemiyorum. Bunu da Scorer.cs scriptinde

using UnityEditor.Rendering;
using UnityEngine;

public class Scorer : MonoBehaviour
{
    [SerializeField] int scoreKeeper = 0;
    void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.tag != "Hit")
        {
            scoreKeeper++;
            Debug.Log("You bumped into " + scoreKeeper + " this many times");

        }
    }
}

- Şimdi de obstacleların rotate etmesini istiyoruz.

- Şöyle bir sorunla karşılaştın: Bir object oluşturduktan sonra scale ederken bir eksende continuous şeklinde scale edememeye başladın
Bunun sebebi de şu, oyun ekranının yukarısında Toggle Grid Snaping denilen bir yer var, grid önünde mıknatıs işareti bulunan bir yapı.
Eğer burayı aktif edersen scale işlemini continuous halde yapmak yerine blok blok yapıyor. Yani bir anda 3 blok ya da 4 blok artırıyor.
Burayı şimdilik kapalı tut.

- Rotate için object oluşturduktan sonra bu objecti ObjectHit.cs ile bağlıyoruz sonra da Spinner.cs scripti oluşturup onu da 
objecte bağlıyoruz.

- Bir objecting rotate eksenini nasıl anlıyoruz. Object dönerken oluşturduğu hayali yüzeyin normal vektörü o objectin unitydeki rotation ekseninin ne 
olduğunu veriyor.

using UnityEngine;

public class Spinner : MonoBehaviour
{
    [SerializeField]float xRotation = 0f;
    [SerializeField]float yRotation = 0.5f;
    [SerializeField]float zRotation = 0f;

    void Start()
    {
        
    }
    void Update()
    {
        transform.Rotate(xRotation,yRotation,zRotation);
    }
}


- Şimdi de bir sphere object ekledik ve projectile yapmasını sağlayacağız. Bunun hareket için Vector3 kullanacağız.
We can store Vector3 as a variable.  C’est une variable (par exemple, la position) qui contient trois valeurs (x, y, z)
Move Towards() metodunu da aynı zamanda kullanacağız. We can use MoveTowards() to make an object move towards a specific point 
in the World. 

- Vector3 is a position in the World, it contains values for x,y,z

- MoveTowards() 3 parametre ister,
	1- o anki pozisyonu(current)
	2- gideceği noktanın pozisyonu(target)
	3- maxDistanceDelta = distance to move each time(how much to move each time we call MoveTowards())
MoveTowards(actuel, cible, distanceMaximale)

- transform.position = Vector3.MoveTowards(transform.position, playerPosition, 1f);
Bu kod satırını update metodu içinde yazıyoruz ve bu kod satırı sayesinde update metodu her çalıştığında scriptin bağlı
olduğu object player'ın konumuna doğru gidecek. Soldaki ifade scriptin bağlı olduğu objectin konumunu tanımlıyor.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{
    Vector3 playerPosition;
    void Start()
    {
        
    }
    void Update()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, 1f);
    }
}
Bu kodda playerın position'ı nerede? Player kim ? Bunları belirtmemiz gerekiyor yani we need to reference to the player
Burada ne yapacağız? İki objecti Inspector içinde birbirine bağlayacağız. Bunun için de Unity'deki bütün objectlerin sahip
olduğu Transform componenti üzerinden bağlayacağız.

using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Start()
    {
        
    }
    void Update()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, 1f);
    }
}

Bu şekilde yazdığında, yani player'ı Transform tipinde oluşturup bunu serializefield olarak tanımladığında 
Unity içinde Projectile objectine tıklayınca sağda açılan Inspector altındaki FlyAtPlayer.cs scriptinin orada
"Player" yazacak ve sağ tarafında ise None(Transform) yazacak. Transform üzerine tıklayıp oradan işte ana objectimizi
yani asıl playerı seçiyoruz.

- playerPosition = player.transform.position; Bu kod bloğunu da start altında yazınca işte şimdi player'ın position'ını 
alacağız. Bunu neden start altında yazıyoruz, çünkü oyunda player sabit ve playerın olduğu yere doğru eğik atış yapacak 
bir sphere var. Diyelim ki eğer bir roket tasarlayacak olsaydık o zaman ana object roket olacağından ve bunun da position değerleri
sürekli değişeceğinden dolayı işte bunun positionını update altında alacağız.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] float speed = 1.0f;
    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Start()
    {
        playerPosition = player.transform.position;
    }
    void Update()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, Time.deltaTime * speed);
    }
}
Burada projectile motion'ı framerate independent hale getirdik bunu da MoveTowards fonksiyonundaki her çağrılmasında ne kadar ilerleyeceğini
gösteren parametre yerine yazdık.

- Inspector altındaki BoxCollider asla kullanıcı tarafından görülemez, açık olsa da olmasa da görülemez ancak bir objectin visible
ya da invisible olmasını istiyorsak o zaman Mesh Renderer ayarı ile oynamalıyız.

- 

using UnityEngine;

public class ObjectHit : MonoBehaviour
{

    void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.tag == "Player")
        {
            GetComponent<MeshRenderer>().material.color = Color.black;
            gameObject.tag = "Hit";

        }        
    }
}
Buradaki  if (collision.gameObject.tag == "Player") kod satırında denmek istenen şey şu:
other things that bumped into us and I want to access the game object itself, bunun da tag'inin Player olması durumunda if
içindeki işlemleri yap. İçerideki collision.gameObject.tag ile gameObject.tag arasındaki fark, ilkinde bu scriptin bağlı
olduğu objecte çarpan objecti refer ederken gameObject.tag kısmında ise bu scriptin bağlı olduğu objecti refer ediyor.

- 3D object altında plane oluşturduğunda, bunun transform altındaki scale kısmına ne kadar y değeri girersen gir, herhangi
bir boyut değişimi göremeyeceksin. Plane 2 boyutlu bir object, o yüzden sadece x ve z değerleri için değişimi görebilirsin.

-  transform.position = Vector3.MoveTowards(transform.position, playerPosition, 1f); Update içinde frame her cagrıldıgında 
objectin transform içindeki position değerleri MoveTowards metodundan dolayı güncellenecek. Yani cisim hareket edecek, bu
hareketten sonra oluşan yeni x,y,z positionları transform.position'a atılacak yani cismin konumu değişecek.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] float speed = 1.0f;
    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Start()
    {
        playerPosition = player.transform.position;
    }
    void Update()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, Time.deltaTime * speed);
    }
}
Buradaki bu kod satırından dolayı [SerializeField] Transform player; Unity arayüzünde sağ tarafta bir player ataması yapmamız gerekiyor.
Bu player'ı projectile yapacak objectimiz olarak tanımlıyoruz, çünkü bu objectin gideceği yer bizim ana playerımızın olduğu konum.

- Şimdi bu aşamada da objectleri yok etme konusunu ele alacağız.

- 
    void DestroyWhenReached()
    {
        Destroy(gameObject);
    }
Burada yok etme metodunu tanımlarken hangi objecti yok edeceğimizi belirtmemiz gerekiyordu. Bu scriptin yani FlyAtPlayer.cs scriptinin
bağlı olduğu objectleri refer etmek için ya da herhangi bir scriptin bağlı olduğu bir objecti refer etmek için "gameObject" kavramını kullanıyoruz.

- Inspector altındaki meshrenderer'e sağ tıklayıp remove diyerek de eklediğimiz objectin iskeletinin kalmasını sağlayabiliyoruz.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] float speed = 1.0f;
    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Start()
    {
        playerPosition = player.transform.position;
    }
    void Update()
    {
        MoveToPlayer();
        DestroyWhenReached();

    }
    void MoveToPlayer()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, Time.deltaTime * speed);

    }
    void DestroyWhenReached()
    {
        if (transform.position == playerPosition) {
            Destroy(gameObject);

        }
    }
}

- Şimdi de trigger olayını halledeceğiz. Ana objectin yakınında cube bir object koyup MeshRenderer'ını kapatacağınız, 
çünkü objectin varlığını değil o objectin kapladığı volume'a gelecek objectlerin trigger edeceği olayı halledeceğiz. Bunu yaparken 
de objectin sağda inspector altındaki BoxCollider altındaki isTrigger kısmını enabled yapmamız gerekiyor.

- Burada da aynen Collision'da olduğu gibi  
	void OnTriggerEnter(Collider other)
    {
        
    }
metodunu kullacagız. Collision'da bu void onCollisionEnter(Collision colision){} şeklindeydi.

- Inspector'ın hemen altındaki yer yani tag'in üstündeki yeri unchecked hale getirirsek o object artık görünmüyor, ancak bu durum 
mesh rendererı unchecked etmekten farklı. Orada objectin iskeletini hala görüyorduk ancak burada artık tamamen görmüyoruz.


- tag'in üstündeki yeri kapatabilmemiz için SerializeField olarak GameObject tipinde bir değişken tanımlamamız gerekiyor.

-
using UnityEngine;

public class TriggerProjectile : MonoBehaviour
{
    [SerializeField] GameObject projectile;
    void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Player") {
            projectile.SetActive(true);
        }
    }
}
Öncesinde 5 tane küre şeklinde projectile yapan objectlerin inspectorun hemen altında tag'in hemen üstündeki
yerden unchecked yaparak yok ettik, yukarıdaki kod bloğu da eğer ana objectimiz trigger volume'den geçerse o projectile 
yapan 5 objecten bir tanesi, ki bunu SerializeField olarak tanımladıktan sonra unity arayüzünde Projectile isimli object'e 
target ettirdik, yani bu object bir anda görünür olacak. Ana object o trigger volumedan geçtiği anda Projectile isimli object de 
görünür olacak, bunu da projectile.SetActive(true); satırıyla yapıyoruz.

- 
using UnityEngine;

public class TriggerProjectile : MonoBehaviour
{
    [SerializeField] GameObject projectile;
    [SerializeField] GameObject projectile2;
    [SerializeField] GameObject projectile3;

    [SerializeField] GameObject projectile4;
    [SerializeField] GameObject projectile5;


    void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Player")
        {
            projectile.SetActive(true);
            projectile2.SetActive(true);
            projectile3.SetActive(true);
            projectile4.SetActive(true);
            projectile5.SetActive(true);
        }
    }
}
O 5 objecti de SerializeField olarak tanımlayıp, inspector içinde atamalarını yapıp hepsini ana object trigger volume'den geçince
ortaya çıkacak şekilde ayarlayacak kod bloğu yukarıda.

- Prefab : reusable asset that represent a GameObject. Bunu harddrive'a prefab olarak kaydediyoruz.
Instance : specific copy of a prefab in our scene

- Burada 5 tane objecti teker teker duplicate ederek oluşturduk ancak ben kürenin yarıçapını değiştirerek
oluşturmak istiyorum, bu durumda her duplicate ettiğimde ayrı ayrı ayarlamalar yapmak zorunda kalacağım. Instance ve
prefab olayı bu ayarlamaları teker teker yapmamak için var. Burada sadece bir tane projectile objecti bırakarak diğer 4ünü
sildik.

- Sonrasında asset içine gelerek Prefab adını verdiğimiz bir folder oluşturduk. Sonrasında solda Hierarchy içinde, prefab yapmak istediğimiz gameobjectin üzerine 
gelip o folderın içine sürükleyerek bırakıyoruz. Hierarchy içinde o gameobject, bu durumda projectile oluyor, mavi bir simge solunda bulunacak şekilde duruyor. 
Asset içindeki Prefab folderındaki Projectile'a sağ tıklayıp "Show in Explorer" dediğimizde artık uzantısının prefab olduğunu görüyoruz. Yani bu object artık
prefab oldu ve hard drive'da duruyor. That's a great way to share particular things from game to game. If you go to the asset store and purchase an asset, then you will be 
able to download it as a package ve bu package file içerisinde birçok prefabs bulunuyor.

- Objecti prefab durumuna getirdikten sonra eğer hierarchy içindeyken yanlışlıkla bu objecti silersem, hala prefab içinde durduğundan dolayı, buradan tutup sürükleyerek objecti
tekrar oluşturabilirim, buna instance diyoruz ve tekrar sürükleyip bırakırsam yine aynı şekilde bu sefer ikincisi oluşur, projectile (2) oluşur.

- Sol tarafta 4 tane instance'ın scale değerlerini değiştirmek istiyorum, o zaman tek tek yapmak yerine prefab folderı içindekine çift tıklayınca oyun ekranında
bizi sadece o objectin olduğu yeni bir yere yönlendiriyor ve orada ayarlama yaptıktan sonra genel oyun yerine geldiğinde bütün instanceların aynı değeri aldığını görüyorsun.

- Bir Instanceın Inspectorı altında Prefab kısmında Overwrite seçeneği var. Eğer bir instance'ın scale değerini değiştirirsen Overwrite altında Revert all ve apply to all kısmı var.
Revert all, başlangıç değerlerine getirirken, apply to all hepsine artık bu değeri uygulayarak prefab'in de değerini değiştiriyor.

- Burada şöyle bir istisna var. Bu 5 sphere objecte colourları sınıflandırdığımız materiallerdan bir colourı birine atadık, sonra atadığımız objectin prefabi altına gelip
overwrite kısmından apply to all diyince bütün hepsi o colora sahip olacak ancak diyelim ki önce birine bir color atadım sonra apply to all demeden sonra diğerine color atadım. 
Bunlardan birinin overwrite kısmından apply to all dersem o zaman diğer ikinci olan hariç hepsi o renge bürünecek. Apply to all kısmı diğerine etki etmeyecek.

- Prefab yapacağın objectleri seçerken dikkat et. Ana player kesinlikle prefab olmalı çünkü scene'den scene'e geçerken bunun kalmasını istiyoruz. Her şeyi prefab içine de taşıyabilirsin.

- Eğer instance'ı duplicate edersen o oluşan aynı object de aynı prefab'den oluşmuş gibi olacak, sürükleyip bırakmanla hiçbir farkı olmayacak.

- Prefablerin hepsini etkileyecek bir değişiklik yapacaksan eğer 2 yolu var: Prefab folder'ı içindekine tıklayarak sağda Inspector altında yapabilirsin ya da instancelardan birini 
değiştirip apply to all diyebilirsin.

- Burada çalıştırdıktan sonra hata alıyoruz çünkü destroy edilen bir objecte sonradan erişmeye çalışıyorsun. Bu neden oluyor? Projectile yapan bir objectler senin bulunduğun konuma doğru 
geliyor ancak sen hala trigger volume'den geçmedin. Objectler sana çarpıp da yok olduktan sonra trigger volume'den geçmek istersen exception atıyor, çünkü trigger volume'den geçmesi
durumunda o objectlere erişip bir şeyler yapacak kodu yazmıştık.

- Unity'nin event functionlar için order of execution'ı var. Unity documentation'da execution order kısmında "Awake" diye bir şey var. Burası Start'tan da önce çalıştırılıyor.
Bundan dolayı öncesinde calıstırılması gereken kodlar varsa bunları Awake içine atmamız lazım.

- 
using UnityEngine;

public class FlyAtPlayer : MonoBehaviour
{

    [SerializeField] float speed = 1.0f;
    [SerializeField] Transform player;
    Vector3 playerPosition;
    void Awake()
    {
        gameObject.SetActive(false);
    }
    void Start()
    {
        playerPosition = player.transform.position;
    }
    void Update()
    {
        MoveToPlayer();
        DestroyWhenReached();

    }
    void MoveToPlayer()
    {
        transform.position = Vector3.MoveTowards(transform.position, playerPosition, Time.deltaTime * speed);

    }
    void DestroyWhenReached()
    {
        if (transform.position == playerPosition) {
            Destroy(gameObject);

        }
    }
}
Bu dosya FlyAtPlayer.cs dosyası. Bunlar projectile yapan objectlere bağlı olan dosya. Bu şekilde awake fonksiyonu eklememizin ana nedenlerinden bir tanesi,
ana object trigger volume'den geçmeden önce projectilelar herhangi bir görünürlük elde etmiyor, ya da harekete geçmiyordu ancak trigger volume'den geçtikten sonra harekete
geçiyordu ancak bu harekette şöyle bir sorun var, projectilelar ana objectin o anlık konumuna gelmiyorlar, başlangıç konumuna gidiyorlar ancak biz trigger volume'den geçtiği
anda oluşsunlar ve o an ana object neredeyse oraya gelsinler istiyoruz. Buradaki sorun order of execution'dan kaynaklanıyor. Awake fonksiyonu bu sorunu düzeltme amacıyla
kullanıldı.

- Hierarchy içinde bir game objectin solundaki göz işareti kolonuna tıklarsan o object scene içinde görünmüyor ama bu yok olduğu anlamına gelmiyor, hala var sadece tasarım yaparken
ya da bir şeyleri ayarlarken dikkatin dağılmasın diye ayarlamak için.

- Oyun içinde bir objecte özellikle ground objectine yanlışlıkla tıklama cok oluyor, bunu kapatmak için hierarchy içinde el işareti olan kolonda tıklamak istemediğin objectin hizasına tıklaman
lazım.

- Bütün walların position'daki y değerlerini aynı yaptık,sebebi de aynı yüksekliğe sahip olmalarını istememiz.

- Bütün objectleri individual olarak seçip rotate ettirirsen her object bulunduğu noktada rotate edecek ancak empty game object altında gruplandırıp o grubu rotate ettirirsen oyun alanı bir bütün olarak
dönecek, bundan dolayı gruplandırmalar önemli.

- TriggerProjectile.cs

using UnityEngine;

public class TriggerProjectile : MonoBehaviour
{
    [SerializeField] GameObject projectile1;
    [SerializeField] GameObject projectile2;
    [SerializeField] GameObject projectile3;
    [SerializeField] GameObject projectile4;
    [SerializeField] GameObject projectile5;

    void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "Player")
        {

            projectile1.SetActive(true);
            projectile2.SetActive(true);
            projectile3.SetActive(true);
            projectile4.SetActive(true);
            projectile5.SetActive(true);
            Destroy(gameObject);
        }
    }
}
Burada Destroy(gameObject); yazdığımızda bu scriptin bağlı olduğu objecti yok ediyor. Bir scriptin bağlı olduğu object ile ayarlamalar yapmak için gameObject kullanıyoruz.
Burada bunu yapmamızın nedeni, trigger volume olduğu yerde kalıyor ancak bundan ikinci defa geçince tekrar projectileları aktif etmeye çalışıyor ancak o projectilelar çoktan yok oldu
bunda da kod exception atıyor bundan dolayı trigger volume'u yok etmek en iyisi.

- Projectile'ların da player'a carptıgında renk değiştirmesini istiyoruz, bu durumda yapacağın şey şu, prefab'lardan projectile'a geleceksin, add component kısmından da ObjectHit.cs'i ekleyeceksin,
böylece bütün projectilelar tek seferde scripte bağlanmış olacak.

- Bir objectin Transform kısmını reset yapabileceğin gibi, bütün değerleri kopyalayıp başka bir objecte de yapıştırabilirsin.

- Hierarchy içinde bir tane empty game object oluşturup, "projectile hazard" bunun altına projectilelar ve trigger volume'u ekledik. Prefab olayının güzel tarafı bu altında 
gruplandırma yaptığımız empty game objecte de prefab olayını yapabiliyoruz. Trigger volume de bir prefabdi, burada nested prefab de yapabilirsin.

- Unity'de küçük bir sorun var nedenini bulamadım ama çözüm var. Bir yerden sonra Mouse'la game scene içinde gezinme hızın cok yavaşlıyor. Mouse'un döndürdüğün o yuvarlak kısmı ile
yaklaşıp uzaklaşma hızın bir noktada cok cok yavaşlıyor, sağ click ile dönme hızın da cok yavaşlıyor, bu durumda bir objecte tıklayıp "F" tuşuna basınca o objecte hızlıca odaklıyor kamerayı ve
Mouse ayarları da normal hızına dönüyor. Çok saçma bir sorun ve çözüm.

- NEW PROJECT (ROCKET)

- Bu projedeki game design felsefesi
	Player Experience : Precision, skillfull
	Core Mechanic : fly carefully and avoid environmental hazard
	Core Game Loop : Get from A to B

- Aynı zamanda ayını tasarlarken game flow and screens kısımlarını da flowchart şeklinde tasarlaman lazım. Level 3'te yanarsan Level1'a dönmeyeceksin, Level3'te tekrar edeceksin gibi...

- Bu projede başka bir projeden import edeceğimiz game objectleri kullanacağız bunun için de .unitypackage uzantısına sahip dökümanı projemizde Assets folderının içinde istediğimiz yere
sürükleyip bırakabiliriz. Sonrasında bu package'de bütün objectler karşımıza çıkacak import butonuna bastıktan sonra Assets folderımızda yeni bir Directory oluşacak ve burada import ettiğimiz package'deki
dataları göreceğiz.

- Models dosyası içinde Fighter, Rover gibi oyundaki elemanlar var. Eğer burada bir elemanı anlamsız bir renkte ve şekilde görürsen, bu case'de pembe, o zaman inspector altındaki Material kısmına gel ve 
colour palette kısmından düzenlemeler yap, içerisinde pembe renk olan bütün objectler için bu düzenlemeleri yap.

-  Burada dikkat etmen gereken nokta, bu oyunu sen 3D eksende yapıyorsun ancak 2D'de ilerleyecek o yüzden +x, -x, +y ve -y eksenlerini ayarlayacak şekilde scene'de kamera görüşünü ayarla.

- Eğer import ettiğin bir modeli unity içinde kullanırken boyutlarını merak ediyorsan, rastgele bir cube oluştur, bunun scale boyutları 1,1,1'dir ve bu küpü kıyaslamak istediğin objectin 
yanına getirerek boyut kıyaslaması yap, ya da scene yüzeyi karelere bölünmüş durumda, bu kareler de unity içinde 1 birim uzunluğa denk geliyor, küp oluşturmadan buna bakarak da kıyaslama 
yapabilirsin.

- Burada önce 3 boyutlu bir küp oluşturarak bunu ground yaptık, sonrasında ise modellerden bir tane launch pad bir tane de landing pad alarak küp üstünde yerleştirdik ve rocketi de launch pad
üzerine koyduk. Şimdi burada bu Scene'i kaydetmek istiyoruz,ayrı kaydetmek istiyoruz çünkü bundan oynamalar yapacağız. Sol üstte File 
kısmına gelip "Save as" diyerek bu scene'i "Sandbox" adını vererek kaydediyoruz ve SampleScene'i siliyoruz.

- Sonrasında burada Assets altında Scripts folderını oluşturup içerisine de "Movement" adında monobehavior scripti yerleştirdik.

- 
using UnityEngine;

public class Movement : MonoBehaviour
{
    void Start()
    {
        
    }
    void Update()
    {
        
    }
}
Buradaki UnityEngine = namespace
Class adı da Movement.

- Namespaces are "containers" for Classes and Classes are containers for Variables and Methods.

- Burada highest level => Namespace. Bunları küme olarak düşünürsen en dışarıda evrensel küme olarak Namespace, sonra altında class, class kümesi içinde 
metodlar ve metodlar içinde de statementlar.

- Encapsulation is kind of a putting a capsule around it so it only knows abput itself. The goal is to limit what the code can see / can change / be changed by 
Burada amaç eger bizim elimizde, diğer şeyleri biz farkında olmadan değiştirebilecek bir şey varsa, bunun sonunda istenmeyen durumlar ortaya çıkabilir, bug, ya da 
istenilen dışında movementlar gibi...

- Eğer encapsulation mantığında ilerleyeceksek, bizim Movement.cs kodunda, sadece burası roketin hızını değiştirebilir.

- We typically aim for a class to do one main thing and not multiple things…

- Mesela diyelim ki Movement class sadece hızı ayarlıyor ancak bir yerde de booster classı var ve bu da hızın artırılmasını sağlıyor. Booster classı 
hızı artırmak istediğinde movement classı ile bağlantı kurması gerekiyor, çünkü biz hız konusundaki talimatları sadece movement classından veriyoruz.

- Unity'de unity ekibi tarafından tanımlanmış birçok class var, bunlara erişmek için relevant namespace'i bilmemiz gerekiyor.

- using UnityEngine.InputSystem; bu namespace'i e Movement scriptine ekledik

- By accesing the class, we acces its content using the dot operator. "ClassName.MethodName();"

- Class ve script burada aynı anlamda kullanılacak çünkü burada her bir scriptte bir class var. Normalde bir scriptte birden fazla class yazabilirsin ancak
biz bir scriptte bir class olacak şekilde ayarlayacağız.

- Bir tane empty game object oluşturup, transform değerlerini resetledikten sonra Launch Pad'e yerleştirdiğimiz rocketin de transform değerlerini resetleyip iki
objectin cakısmasını sağlıyoruz sonrasında da rocket objectimizi hierarchy içinde empty game object'in child'ı yapıyoruz. Why did we do this ? What I want to do 
is put all of my scripts and rigidbody and logic onto the parent level, because then it is gonna control everything thats going to go on. It is gonna control the left
and the right. It is gonna control how it moves and the child underneath is just how it looks, it is just a visuals of it. Ne zaman görüntüsünü değiştirmek istesem,
o zaman child'ı silip istediğim şeyi atabilirim empty objectin içine, bütün logic ve scriptleri de parent'a bağladığım için de herhangi bir kaybım olmaz.

- Burada simplest input approach kullanacağız, buna Input Action Bindings in the inspector diyoruz. Input Actions allow us to use multiple input systems(keyboard, controller) to do
specific things in our game. Eg spacebar or trigger to control thrusting.

- Kullanacagımız input system approach'ı için izleyeceğimiz adımlar :
	1- Use the UnityEngine.InputSystem namespace
	2- Create InputAction variables(that are serialized)
	3- Add bindings for each InputAction
	4- Enable each InputAction
	5- Use the value of InputAction for gameplay
	6- Disable each InputAction if/ when we need to turn off input

-
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
}

Burada InputAction typeında bir değişkenimiz var ve şimdi de bunu enable hale getirmemiz gerekiyor.

- Unity'nin dökümantasyonunda order of execution'ı incelerken en üstte Awake fonksiyonu vardı, onun hemen altında da OnEnable fonksiyonu var. Bunlar Start fonksiyonundan 
önce gerçekleşen şeyler. Dökümantasyonda sırasıyla Awake -> OnEnable -> Reset -> Start … ilk dördü oluşturuyor. Initialization kısmında Awake ve OnEnable varken, Editor kısmında 
Reset var ve yine Initialization kısmında Start var.

- It might be you have your game object come alive at the start of the game and then you want to pause it or turn it off when the player dies, and then turn it back on again 
and turn it off and turn it. So the protocol for turning our input actions on and off is to use OnEnable as the callback for turning them on and OnDisable. Bu fonksiyon da 
order of execution'da en alttan bir üstte. En altta OnDestroy fonksiyonu var.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    void OnEnable()
    {
        thrust.Enable();
    }
}

Aynı Start() ve Update() metotlarında olduğu gibi burada da OnEnable metodunu yazıp, InputAction tipindeki değişkenimizi Enable() fonksiyonunu çağırarak enabled duruma getiriyoruz.

- Burada değişkeni SerializeField olarak tanımladık, bundan sonra Unity arayüzüne gelip "Player Rocket" olarak adlandırdığımız ve model rocketin parentı olarak ayarladığımız empty game objectimizin 
inspectorunda script altında Thrust değişkenini görüyoruz. O değişkenin yanında "+" işareti var, burası "bindings" kısmından sorumlu.

- The binding is basically saying what is the key press or button thing or the direction of the controller that you want me to bind to this particular variable.

- Binding'i temsil eden +'ya tıkladıktan sonra "Add Binding" diyoruz. Altında "<No Binding>" yazan bir yer açılıyor. Buraya çift tıkladıktan sonra "Path" kısmından neyle bağlayacağın kısmına burada karar veriyorsun. Burada keyboard,
Mouse, joystick, pointer, pen, sensor... gibi bir çok seçenek var. Biz "space" tuşunu thrust olarak kullanacağımız için Keyboard'dan space'i seçiyoruz. Seçeceğin şeyi bulamazsan Path kısmına tıklayınca Listen var,
burası senin keyboardda basacağın tuşu dinliyor, buna tıkladıktan sonra space'e basarsan da istediğin sonucu elde edersin. Burada space'e ek olarak, Game Pad'den Right Trigger kısmını da ekliyoruz.

- Bu ayarlamaları yaptıktan sonra kontrol etmemiz gerekiyor. 
	1- Create an if statement to print something when we are pressing the space key
	2- In Update(), check if thrust.IsPressed() is true.
	3- If it is true, print smt to the console

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    void OnEnable()
    {
        thrust.Enable();
    }
    void Update()
    {
        if (thrust.IsPressed())
        {
            Debug.Log("THRUST!!!");
        }
    }
}

- Bir objecti oyun içinde hareket ettirmenin 2 yolu var, ya Transform altındaki position değerlerini değiştireceksin ya da Unity Physics system kullanacaksın, yani biraz kuvvet uygulayacaksın ve
fizik sistemi geri kalan her şeyi halledecek. Burada gravity felan da devreye girmesi gerektiği için önce rigidbody eklememiz gerekiyor. Parent game objectimize, Player Rocket diye adlandırdığımız,
add component kısmından rigidbody ekliyoruz ancak bunu ekledikten sonra oyunu calıstırdıgımızda rocket aşağı tarafa doğru gitmeye başlıyor çünkü collider yok. BoxCollider'ı da eklememiz gerekiyor.
Burada boxCollider'ın center ve size değerlerini objectimizi kaplayacak şekilde ayarlıyoruz. Tıklayınca bu sefer üzerinde durduğu Launching Pad'in içinden geçip ground'un üzerinde kaldı. Bunun için
Launchin Pad'e de collider eklememiz gerekiyor.

- Imported assetlerle ilgili önemli bir detay var, if we import an fbx model we can drop it into our scene however we like. Scale it, rotate it... However we cant alter the original model file, we cant alter
the FBX file itself thats why, we cant "apply back to prefab". If we use one of these models from our scene to create a prefab, it will create a "prefab variant". Changes made to one Prefab Variant Instance will be
applied to other instances, but not the original artwork.

- Prefab Variant oluşturmak için de önce asset folderında önceki projede yaptığımız gibi Prefab folderı oluşturuyoruz. Launching ve Landing pad'leri import ettiğimiz modelleri sürükleyip bırakarak yapmıştık ancak burada
landing pad'i kaldırıyoruz. Launching pad'i prefab folderına sürükleyerek "prefab variant" haline getirdik. Bu aslında bir şeyin kopyasının kopyası gibi. Artık burada aynen prefablerdeki instancelara yaptığımız "apply all"
seçeneğini kullanabileceğiz.

- Prefab variant'ı landing pad olarak scene'e ekledik. Collider'ı içinde geldi.

- Rocketimize rigidbody ekledik, bunu kod dosyamızda da tanımlayıp, buna erişmemiz gerekiyor. "RigidBody rb;" şeklinde tanımlıyoruz.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    Rigidbody rb;
    void OnEnable()
    {
        thrust.Enable();
    }
    void Update()
    {
        if (thrust.IsPressed())
        {
            Debug.Log("THRUST!!!");
        }
    }
}

-
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
    }
    void Update()
    {
        if (thrust.IsPressed())
        {
            Debug.Log("THRUST!!!");
        }
    }
}

RigidBody'nin componentlerini "rb" değişkenine atadık. Buradan sonra da Update içinde force uygulamamız gerekiyor ancak buradaki update, FixedUpdate() metodu.
Bunu unity dokümantasyonundaki order of execution'daki "Physics" kısmının en başındaki fonksiyon olarak göreceksin. Update fonksiyonu ise Game Logic kısmında.

- Burada dikkat etmen gereken nokta eğer Update() ve FixedUpdate() fonksiyonlarında ayrı ayrı fiziksel işler yaparsan işleri kontrolden çıkarırsın, kameranın 
titremesini görürsün. Bundan dolayı kod dosyamızda tanımladığımız Update metodunun adını FixedUpdate olarak değiştiriyoruz.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
    }
    private void FixedUpdate()
    {
        if (thrust.IsPressed())
        {
            Debug.Log("THRUST!!!");
        }
    }
}

- Burada local ve global positionlara dikkat etmen gerekiyor. Global positionlar, scene'de sağ üstteki koordinat düzleminin gösterdiği poisitionlar ve asla değişmezler. Yani sen eğer globalde
y ekseninde force uygularsan y'de ilerleyecek ancak diyelim ki rocketini 45 derece saat yönünde yatırdın ve global positiondayken yine force uyguladın o zaman 45 açıyla ilerlemen gerekirken yine dikey kalkış
yaparsın ki bu da roket mantığına aykırı. Local position kullandığında ise, roketi 45 derece saat yönünde yatırırsan eksenler de , y ekseni de 45 derece saat yönünde yatacak ve thrusterlar calıstıgında roket
45 derece saat yönünde ilerleyecek.

- Burada ekleyeceğimiz force fonksiyonu, addrelativeforce olacak çünkü bu force local positionlar ile alakalı.

- Rigidbody componentindeki mass ile oynayabilirsin.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
    }
    private void FixedUpdate()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(100,0,0);
        }
    }
}

- rb.AddRelativeForce(0,10,0); bu kod bloğu bizim objecti yukarı taşımak için gereken kod bloğu, aynı işi rb.AddRelativeForce(Vector3.up); ile de yapabiliriz.

- Burada yapacağımız birkaç işlem kaldı. Vector3.up 'ın karşılığı (0,1,0). Bunu güçlendirmemiz için thrustStrength değişkeni oluşturacağız, sonrasında da bunu
frame rate independent yapmamız lazım. Önceki projede Update metodu içindeyken Time.deltaTime kullanmıştık ancak burada FixedUpdate içindeyiz, bundan dolayı
Time.fixedDeltaTime kullanacağız.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] int thrustStrength = 100;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
    }
    private void FixedUpdate()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
        }
    }
}

Burada Time.fixedDeltaTime'dan dolayı rocket çok çok az ilerliyor çünkü bu değer bayağı küçük. Bundan dolayı strength'i çok yüksek bir değere çekmemiz lazım.

- Şimdi de rotation binding yapacağız, sağ ok tusu bize 1 değerini verirken sol ok tusu bize -1 değerini verecek.

- Şimdi movement scripti içinde InputAction tipinde bir SerializeField olarak bir rotation değişkeni tanımlayacağız sonrasında da bunu OnEnable fonksiyonu içinde
enable haline getireceğiz. Sonrasında da unity arayüzüne gelince sağda inspector altındaki script altında değişkeni göreceğiz. Burada +'ya tıklayarak binding yapacağız
ancak ilkinde yaptığımız gibi add binding değil, burada negatif ve pozitif değerler de işin içine gireceği için seçimi ona göre yapacağız. Burada seçeceğimiz kısım "Add positive/negative binding"
Sonrasında eklenen yerde negative binding kısmına keyboard -> left arrow 'u atarken, positive binding kısmına keyboard -> right arrow kısmını atacağız. Rotation altındaki "1D Axis" yazan 
ve keyboard ayarının oldugu yerdeki bu "1D Axis" yazısını değiştirip istediğini yazabilirsin, buraya Keyboard yazdık. Burada aynı şekilde, rotation'a bir de gamepad için ekleme yapacağız. 
Burada gamepad kısmından negatif ayarını left stick/left olarak değiştirip, sağ ayarını da right stick/right olarak değiştireceğiz.

- Burada yazacağımız kodda if (rotation.IsPressed()) tarzında bir şey kullanamayız çünkü rotation'ın negatif ve pozitif değerlerine ayrı ayrı tuş tanımladık. Burada yapacağımız
şey "ReadValue<float>"  kullanmak, çünkü bastığımız ok tuşlarından okuyacağımız değer ya pozitif olacak ne ya negatif olacak. Buradan bir değer döndüreceği için bunu da bir değişkene
atamamız gerekecek.

- "ReadValue<float>" bu şekilde yazsak bile burada ya 1 ya da -1 değeri dönüyor.

- Burada sonraki aşama, bu zamana kadar script, rigid body ve collider eklediğimiz roketin parent objectini yani Player Rocket'ı Prefab folderının içine atıp Prefab Variant
durumuna getiriyoruz.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 100;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        Debug.Log("Rotation : " + rotationInput);
    }
}
   
- Buraya şimdi de şunu ekleyeceğiz, eğer rotation değeri pozitif ise sağa rotate et, negatifse sola rotate et

- 
private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            transform.Rotate(0f, 0f, 1f);
        }
    }

Buradaki rotate kısmında koordinatları Vector3 ile de yazabiliriz.

private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            transform.Rotate(Vector3.forward);
        }
    }

Burada Mouse ile "forward" yazısı üzerine geldiğimizde bize (0,0,1)'e eşit olduğunu söylüyor.Oyunu çalıştırdıgında pozitif value'nun oyunda
sola rotate ettirdiğini görüyorsun, bundan dolayı transform.Rotate(Vector3.forward); kod satırını transform.Rotate(Vector3.back); olarak değiştireceksin,
bu da bize (0,0,-1) değerini verecek. Ya da bunun diğer bir yolu ise transform.Rotate(-Vector3.forward); yazmak yani Vector3 değerinin başına minus sign
koymak.

- İki tane if condition'ı alt alta yazmak bu case için sıkıntılı, ya aynı anda hem negatif hem pozitif değer gelirse ne olacak. Bundan dolayı if-elseif yapısını
burada kullan.

- Şimdi rotation'ı frame rate independent yapacagız ancak Time.fixedDeltaTime değeri çok çok küçük oldugu için, thrust'a yaptıgımız gibi rotationStrength adında bir değişken
tanımlayıp onu kullanacagız. 

-
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 1000;
    [SerializeField] float rotationStrength = 1000f;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            transform.Rotate(Vector3.back * rotationStrength * Time.fixedDeltaTime); // transform.Rotate(-Vector3.forward);
        }
        else if (rotationInput < 0)
        {
            ApplyRotation(rotationStrength);
        }
    }
    private void ApplyRotation(float rotationThisFrame)
    {
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
    }
}
Burada methodları parametrelerle tanımlamayı görüyoruz. RotationInput'ın pozitif olduğu durumda da ApplyRotation(-rotationStrength) yazacağız. Normalde minus sign ı Vector3 önüne koymuştuk ancak
çarpım durumunda olduğu için nerede olacağının cok bir önemi yok.

-
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 1000;
    [SerializeField] float rotationStrength = 1000f;
    Rigidbody rb;
    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            // transform.Rotate(Vector3.back * rotationStrength * Time.fixedDeltaTime); 
            // transform.Rotate(-Vector3.forward);
            ApplyRotation(-rotationStrength);     
        }
        else if (rotationInput < 0)
        {
            ApplyRotation(rotationStrength);
        }
    }
    private void ApplyRotation(float rotationThisFrame)
    {
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
    }
}

- Şimdi de rocketi takip edecek bir cinemachine camera eklememiz gerekecek.

- Window -> Package Manager ve buradan da cinemachine kamerayı ekle ve hierarchy içinde de "cinemachine camera"yı ekle.
Sonrasında da Main Camera'ya tıkla ve sağda inspector altında "cinemachine camera brain"'in eklenip eklenmediğini kontrol et.

- Hierarchy altındaki "Cinemachine Camera"'ya tıkla ve sonrasında da sağda "Tracking Target"'ı Rocketin parent objecti yap. Sonrasında biraz altında 
"Procedural Component" kısmındaki Position Control, Rotation Control değerlerini ayarlar. Position Control değerini "Follow"'a çek, Rotation Control değerini
ise "None"da bırak çünkü kameranın rotate edeceği bir oyun değil. Sonrasında da alt tarafta Position Control'u Follow yaptıktan sonra açılmış olan "Cinemachine Follow"
kısmından da Follow Offset ayarlarını ayarlayarak kameranın konumunu netleştir.

- Yukarıda Game sekmesi altında "Free Aspect" ayarından ekran ratiolarını ayarlayabilirsin.

- Şimdi de Rotation Control kısmını "Spline Dolly Look At Targets" olarak değiştiriyoruz.

- Burada dikkat edersen, oyun ve kamera titriyor, bunun sebebi de daha öncesinde belirttiğimiz gibi Update metodu. Bu sorunu çözmek için
Main Camera objectine geliyoruz, Altta "Cinemachine Brain" altında "Update Method" var. Burası "Smart Update" olarak ayarlanmış ancak bunu "FixedUpdate"'e çekiyoruz aynı şekilde
onun hemen altındaki "Blend Update" kısmını da FixedUpdate'e çekiyoruz.

- Sonrasında Cinemachine Camera'ya gelip Position Control kısmını "Position Composer" olarak ayarlıyoruz. Position Composer olarak ayarladıktan sonra ekranda origini rocket olan
bir x-y ekseni çıkıyor. Burası sürekli roketi takip edecek ancak biraz gecikmeli ile takip ediyor.

- Position Control'u Position Composer olarak ayarladıktan sonra aşağıda açılan Cinemachine Position Composer'ın ayarlarından kamera mesafesi, screen position gibi değerleri ayarlıyoruz.
Screen position bize kamera offset değerlerini ve roketin kamera ekranında nerede konumlanacağını gösteriyor.

- Cinemachine Position Composer ayarlarında Dead Zone kısmı var. That's how far you can slide before the camera moves. Bunun da altında "Hard Limits" var. Hard Limits means that
the camera will never, ever, ever let you go further than that off the screen. 

- Dead Zone, çerçevenin (kamera ekranının) merkezinde tanımlanan bir dikdörtgen alandır. Hedef (örneğin karakter) bu alan içinde kaldığı sürece kamera hareket etmez. Hedef bu bölgenin dışına çıkarsa, kamera onu tekrar merkeze getirmek için hareket eder.

- Hard Limits, hedefin (örneğin karakterin) kameranın çerçevesinde gidebileceği en uzak sınırları belirler. Bu sınırlar aşıldığında, kamera zorla hedefi tekrar Dead Zone içine çekmeye çalışır.

- Dead Zone küçük, Hard Limit geniş: Karakter biraz uzaklaşabilir ama ekran dışına çıkmadan önce kamera devreye girer.

Hard Limit = Dead Zone: Kamera karakter Dead Zone'dan çıkar çıkmaz ani tepki verir.

Hard Limit yok (kapalı): Kamera sınırsızca karakterin hareketine izin verir, sadece Dead Zone’a göre çalışır.

- Burada yapacağımız bazı işlemler var :
	1- Plonk in an obstacle
	2- Freeze constraints for our rocket
	3- fix our obstacle-hitting bug due to momentum
	4- set our drag value
	5- fiddle with World gravity

- Önce Player Rocket'in Inspector'ı altında z eksenindeki position'ı constraint kısmında checked durumuna alman lazım çünkü bunun sadece x ve y ekseninde
translate etmesini istiyoruz aynı şekilde rotation eksenlerindeki constraintler için de E tuşuna basarak rotate etmesini istediğin eksene bak ve diğer eksenleri
dondur. Burada sadece Z ekseni açık kalacak xy eksenlerini dondur.

- Şimdi de import ettiğimiz package içinden bazı modelleri oyun içine ekleyeceğiz. Silindir şeklinde bir uzay kapsülünü oyuna ekledik ancak roketimiz bunun içinden geçiyor, 
bunu engellemek için bu object'e box collider eklememiz gerekiyor ancak bu box collider capsule collider olmalı, çünkü silindir bir objecte küp şeklinde collider eklemek mantıklı 
değil.

- Bu capsule collider'ın center, height ve Radius değerleriyle oynayarak bu objectin çarpışma sınırlarını mantıklı hale getiriyoruz.

- 
 private void ApplyRotation(float rotationThisFrame)
    {
        rb.freezeRotation = true;
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
    }
Buraya rb.freezeRotation = true; bu kodu yazmamızın sebebi, fizik sistemine sen rotate etme, rotation sadece biz sağlayacağız demek. Sonrasında da
tekrar rotation'ı sen devralabilirsin dememiz lazım

private void ApplyRotation(float rotationThisFrame)
    {
        rb.freezeRotation = true;
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
        rb.freezeRotation = false;
    }
Bunu da bu şekilde yapacağız.

- Burada scene'e eklediğimiz kapsülün diğer adıyla tankın özelliklerini import ettiğimiz dosyasından farklı hale getirdik. Bunu ileride de kullanmak için
kendi prefab dosyamıza ekliyoruz.

- "Drag" kavramı unity içinde tekrardan adlandırıldı. Bunun yeni adı "Damping". Burada bahsettiğimiz şey RigidBody altındaki Linear Damping.
Drag is basically imagine the wind resistance as you fly through the atmosphere. So dampening factors that affect how this body resists linear 
motion. Drag değerini yani linear damping değerini cok fazla yaparsan roketi yerinden kaldıramazsın çünkü cok fazla dirençle karşılaşırsın.

- Gravity değerini oyunda değiştirmek istiyorsan, o zaman Edit -> Project Settings -> Physics altındaki Settings kısmından Gravity'nin değerlerini değiştireceksin.

- Artık Unity'nin audio kısmıyla uğraşma zamanı. Burada bazı ses efektlerini ekleyeceğiz. Bunun için 3 ana şeye ihtiyacımız var : 
	1- audio file'a ihtiyacımız var, burada kullanacağımız audio filelar .mp3, .ogg ya da .wav uzantılı olabilir. 
	2- bu audio dosyasını unity içinde oynatmak, that's smt that needs to sit as a component on a game object, an audio source
	3- audio listener, that's the thing that we'll be able to hear the audio.

- Eğer Main Camera'ya tıklarsan Inspector altında Audio Listener componentini göreceksin. Burası olmadan bizim sesi duymamız mümkün değil. Aynı şekilde bizim "3D Spatial Sound"
kurmamız gerekiyor ki, sesin kaynağı uzakta olursa ve yakında olursa duyma şekillerini ona göre ayarlasın.

- Şimdi ses çıkaracak objectlere "Audio Source" componentini eklememiz gerekiyor. Bundan dolayı Player Rocket objectimize gelip "Add Component" diyerek buradan Audio Source'u ekleyeceğiz.
Ekledikten sonra Inspector altındaki Audio Source componentinden bu sesin ayarlarını yapacağız.

- Birden fazla audio eklenebilir ve triggered durumlara göre değişebilir ancak burada 1 tanesiyle başlayacağız.

- Sesler konusunda da freesound.org sitesinden istediğin soundları arayabilirsin.

- Assets folderı altında "Audio" adında bir folder oluşturuyoruz ve ses dosyalarımızı buraya atıyoruz.

- Eğer kendi sesini yapmak istiyorsan "Audacity" isimli yazılımı indirip yapabilirsin. Bu programda kaydettiğin sesin neredeyse bütün özellikleriyle oynayabilirsin. Hızlandırabilirsin,
yavaşlatabilirsin, high pitch yapabilirsin...

- Player Rocket'e gelip audio resource kısmını main engine thrust olarak ayarlıyoruz. Altındaki ayarlardan "Play on Awake" kısmı checked durumda ise bu şu demek, oyunda Start butonuna bastığım 
anda bu ses dosyası çalacak. Ancak ses dosyası sona geldiğinde çalmayı bırakacak, bunun sürekli çalmasını istiyorsan Loop seçeneğinin de checked durumda olduğundan emin olman lazım.

- Burada yapacağımız şey, bu sesin sadece thrusterlar acık olduğunda çalması yani sadece space tuşuna basınca bu sesin çıkmasını istiyoruz. Bunun için yapmamız gereken, audio source componentine 
erişip, sonrasında AudioSource.Play() metodunu ve AudioSource.Stop() metodunu if yapısı içinde kullanman lazım. Sonrasında da Play on Awake kısmını unchecked haline getiriyoruz.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 1000;
    [SerializeField] float rotationStrength = 100f;
    AudioSource audioSource;
    Rigidbody rb;
    void Start()
    {
        audioSource = GetComponent<AudioSource>();
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
            audioSource.Play();
        }
        else
        {
            audioSource.Stop();
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            // transform.Rotate(Vector3.back * rotationStrength * Time.fixedDeltaTime); 
            // transform.Rotate(-Vector3.forward);
            ApplyRotation(-rotationStrength);     
        }
        else if (rotationInput < 0)
        {
            ApplyRotation(rotationStrength);
        }
    }
    private void ApplyRotation(float rotationThisFrame)
    {
        rb.freezeRotation = true;
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
        rb.freezeRotation = false;
    }
}
    
Burada karşılaştığım sorunlardan biri space'e basınca sound effect üstü üstüne biniyor ve bu onlarca aynı sound üstü üstüne biniyor istenilen ses çıkmıyor. Bunun için
kod satırına, eğer bu ses dosyasını çalıştırıyorsan bir daha calıstırma, yani sadece bir kere calıssın bitince bir daha çalışsın diyoruz. Çünkü Space tuşuna her bastığımızda
bu ses dosyası bastan bir daha calıstıgı için parazit sesi çıkarıyor. Bunun için de

if(!audioSouce.isPlaying)
{
	audioSouce.Play();
}
kodunu ekleyeceğiz. Bunun anlamı eğer space'e bastığımda audiosource çalmıyorsa çalsın yoksa çalmasın.

- Düzeltilmiş haliyle bu : 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 1000;
    [SerializeField] float rotationStrength = 100f;
    AudioSource audioSource;
    Rigidbody rb;
    void Start()
    {
        audioSource = GetComponent<AudioSource>();
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
            if (!audioSource.isPlaying)
            {   
                audioSource.Play();
            }
        }
        else
        {
            audioSource.Stop();
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            // transform.Rotate(Vector3.back * rotationStrength * Time.fixedDeltaTime); 
            // transform.Rotate(-Vector3.forward);
            ApplyRotation(-rotationStrength);     
        }
        else if (rotationInput < 0)
        {
            ApplyRotation(rotationStrength);
        }
    }
    private void ApplyRotation(float rotationThisFrame)
    {
        rb.freezeRotation = true;
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
        rb.freezeRotation = false;
    }
}
    

- Şimdi Launch Pad'e gelip buradan iki tane tag ekliyoruz, bir tanesi "Friendly", diğeri de "Finish". Sonrasında 3 boyutlu bir sphere ekleyip z koordinatını 0'a ayarlıyoruz.
Buna da yeni bir tag ekliyoruz "Fuel". Sonrasında da Landing Pad'in tagini Friendly, Launch Pad'in tagini Finish, Sphere tagini de Fuel olarak ayarlıyoruz.

- Script dosyasına gelerek CollisionHandler adında monobehavior script oluşturduk ve bunu da roketin parenti olan Player Rocket ile bağladım.

- Bu scriptte switch statement kullanacağız. Switch statements are a conditional like if/else statements and allow us to compare a single variable to a series of constants
Switch statement syntax'ı

switch (variabletoCompare)
{
	case ValueA:	
		Statements;
		break;
	case ValueB:
		Statements;
		break;
	default:
		Statements;
		break;
}

- Bu scriptte onCollisionEnter metodu kullanacağız, bu metodda carptıgımız objectle ilgili metodun parametresinden dolayı bilgi alabiliyoruz. 
void OnCollisionEnter(Collision collision)
    {
        
    }
Bu metodun içinde çarptığımız objectin tagine "other.gameObject.tag" diyerek erişebiliyoruz. Burada dikkat etmen gereken nokta, dönecek tag değeri string olarak 
gelecek.

- 
using UnityEngine;

public class CollisionHandler : MonoBehaviour
{
    void OnCollisionEnter(Collision collision)
    {
        switch (collision.gameObject.tag)
        {
            case "Friendly":
                Debug.Log("BEGIN");
                break;
            case "Finish":
                Debug.Log("FINISH");
                break;
            case "Fuel":
                Debug.Log("FUEL");
                break;
            default:
		Debug.Log("CRASHED");
                break;

        }
    }
}

- Scene Management ile ilgileneceğiz. File -> Build Profiles tıklayınca Windows, Mac, Linux ... gibi ifadelerin oldugu bir ekran acılacak. Windows kısmının sağ tarafında "Active" yazıyor.
That allows us to build to a whole bunch of different platforms. Burada Windows için Web için mobil platformlar için ya da diğer platformlar için ayarlamalar yapıyoruz.
En üstte SceneList yazan kısma geliyoruz. What are the scenes that we will have in our game ? Burada, bu projenin başlarında sildiğim SampleScene'i görüyorum ancak yanında deleted yazıyor.
Bunu tamamen bu listeden kaldırdıktan sonra sağ altta "Add Open Scenes" yazısına tıklayınca öncesinde oluşturdugum Sandbox scene'inin buraya eklendiğini görüyorum.

- Scenes are a way for us to manage for our particular project to manage levels. Yani her bir scene aslında oyunda bir level'ı temsil edecek. 

- Scene List'te Scenes/Sandbox yanında 0 sayısını görüyorsun, bu sayı bu scene'in indexi. Bu önemli bir information, ileride bunu kullanacagım.

- Burada yapacagımız şey, bir objecte çarparsan Scene tekrar yüklemek. Unity dökümantasyonunda SceneManager kısmını incelersen orada Load Scene, Merge Scene gibi static 
metodları  göreceksin. Mesela Load Scene metoduna parametre olarak göndereceğimiz değerlerden biri de sceneBuildIndex. Bu index az önce SceneList'deki, scene adlarının yanındaki
indexi temsil ediyor ya da aynı parametrenin oldugu yere Scene ismini string olarak da gönderebilirsin.

- 
using UnityEngine;
using UnityEngine.SceneManagement;

public class CollisionHandler : MonoBehaviour
{
    void OnCollisionEnter(Collision collision)
    {
        switch (collision.gameObject.tag)
        {
            case "Friendly":
                Debug.Log("BEGIN");
                break;
            case "Finish":
                Debug.Log("FINISH");
                break;
            case "Fuel":
                Debug.Log("FUEL");
                break;
            default:
                Debug.Log("CRASHED");
                SceneManager.LoadScene(0);
                break;

        }
    }
}
Buradaki kod Crashed durumunda oyunu başa alıyor, "SceneManager.LoadScene(0);" satırı bunu sağlıyor. Bu satırı yazabilmemiz için de 
yukarıda using UnityEngine.SceneManagement; satırını yazıp SceneManagement namespace'ine ulaşmamız lazım.

- 
void ReloadLevel()
    {
        SceneManager.LoadScene(0);
    }
Bu metodu yazıp default altında çağırarak scene yükleme işlemini daha modüler hale getirdik ancak burada şu eksik var, burada 
yüklemek istediğimiz scene'in indexine ulaşarak tekrar yükleme yap komutunu vermemiz lazım yoksa her scene için manuel olarak tanımlamak zorunda kalacağız.

- 
void ReloadLevel()
    {
        int currentScene = SceneManager.GetActiveScene().buildIndex;
        SceneManager.LoadScene(currentScene);
    }
Burada içinde bulunduğumuz Scene'in indexini alıyoruz ve roketimiz bir yere çarpması durumunda tekrar scene'i yüklüyoruz.

- Bu aşamada da next scene'i yükleme işlemini halledeceğim. Bunun için önce şu an içinde bulunduğumuz scene'in adını Sandbox'tan "Over" durumuna getiriyorum.
Scenelere içindeki senaryoya uygun isimler ver.

- Buradaki Fuel tagine sahip objectten kurtul. Sonrasında roketin parent objecti olan Player Rocket'e gel ve sağda inspector altında Prefab kısmından "Apply all" diyerek
parentta yaptığımız değişikleri prefab'e uygula.

- Scene folderına gelerek sağa tıklayıp create->scene diyerek scene oluşturup tekrardan objectleri içine atabilirsin ancak bu scene'de biraz değişiklik yapıp ikinci scene'i öyle 
çıkartmak istiyorsan o zaman var olan scene'i, yani Over'ı, kopyalayıp onu değiştirerek ikinci levelını kurabilirsin.

- Scene'i duplicate ettikten sonra aradaki kapsülü yukarı kaldırdık ve roketin alttan geçmesinin yolunu hazırladık. Sonrasında bu scene'i de duplicate ederek kapsül sayısını iki yapıp
ikisi arasından geçeceği yeni bir scene tasarladık. Scenelerin isimleri Over, Under ve Through

- Sonrasında File->Build Profile kısmına gelerek SceneList'e yeni oluşturduğumuz Scene'leri Asset altından tutup sürükleyerek Scene List'e ekliyoruz. Burada şuna dikkat et, ekledikten sonra
yanlarında indexler otomatik olarak oluşuyor. Scene sıramalasına yani aslında Level sıralamasına dikkat et.

- 
using UnityEngine;
using UnityEngine.SceneManagement;

public class CollisionHandler : MonoBehaviour
{
    void OnCollisionEnter(Collision collision)
    {
        switch (collision.gameObject.tag)
        {
            case "Friendly":
                Debug.Log("BEGIN");
                break;
            case "Finish":
                Debug.Log("FINISH");
                LoadNextLevel();
                break;
            case "Fuel":
                Debug.Log("FUEL");
                break;
            default:
                Debug.Log("CRASHED");
                ReloadLevel();
                break;

        }
    }
    void LoadNextLevel()
    {
        int nextScene = SceneManager.GetActiveScene().buildIndex + 1;
        SceneManager.LoadScene(nextScene);
    }
    void ReloadLevel()
    {
        int currentScene = SceneManager.GetActiveScene().buildIndex;
        SceneManager.LoadScene(currentScene);
    }
}
Burada son bir ayar kaldı o da scenelerde sona ulaştığının kontrolünü yapmak. Bunun için oyunda kaç tane scene olduğuna kodda erişmen lazım.
Bu değere SceneManager.sceneCountInBuildSettings ile ulaşıyoruz.

- 
 void LoadNextLevel()
    {
        int nextScene = SceneManager.GetActiveScene().buildIndex + 1;
        if (nextScene == SceneManager.sceneCountInBuildSettings)
        {
            nextScene = 0;
         }
        SceneManager.LoadScene(nextScene);
    }
LoadNextLevel metodunu, eğer total scene number'a ulaştıysak başa dön şeklinde güncelledik.

- Bu aşamadan sonra Invoke kullanacagız. Bunu kullanma amacımız, bir yere carptıktan sonra hemen başa dönmesin, biraz delay olsun ve carptıgını görsün istiyoruz.

- Using Invoke() allows us to call a method so it executes after a delay of x seconds, yani bir metodu birkaç saniye sonra çalıştırmak için kullandıgımız bir şey.
Invoke metodunun syntax'ı Invoke("MethodName", delayInSeconds); Burada dikkat et, method adını string reference olarak veriyoruz.

-
default:
      Debug.Log("CRASHED");
      Invoke("ReloadLevel", 2f);
      break;

Switch'in default kısmında Invoke metodunu yazmana ragmen calısmadı neden ? Bunun sebebi tanımladıgın LoadNextLevel ve ReloadLevel metodlarını onCollisionEnter metodu içine koyman.
Invoke metodu, içinde bulundugun metodu taramaz, o metodun dışındakileri tarayıp da gecikmeli cagırmak istediğin metodu bulur. Bundan dolayı LoadNextLevel ve ReloadLevel metodlarını
onCollisionEnter metodu dışına al.

-
using UnityEngine;
using UnityEngine.SceneManagement;

public class CollisionHandler : MonoBehaviour
{
    void OnCollisionEnter(Collision collision)
    {
        switch (collision.gameObject.tag)
        {
            case "Friendly":
                Debug.Log("BEGIN");
                break;
            case "Finish":
                Debug.Log("FINISH");
                LoadNextLevel();
                break;
            case "Fuel":
                Debug.Log("FUEL");
                break;
            default:
                Debug.Log("CRASHED");
                Invoke("ReloadLevel", 2f);
                break;

        }
    }
    void LoadNextLevel()
    {
        int nextScene = SceneManager.GetActiveScene().buildIndex + 1;
        if (nextScene == SceneManager.sceneCountInBuildSettings)
        {
            nextScene = 0;
         }
        SceneManager.LoadScene(nextScene);
    }
    void ReloadLevel()
    {
        int currentScene = SceneManager.GetActiveScene().buildIndex;
        SceneManager.LoadScene(currentScene);
    }
}
Son hali

- Bu kısım da tamamlandıktan sonra şimdi de bir yere çarpma durumunda ses çıkmasını ve particle efektini eklemeyi halledeceğim. Aynı zamanda burada şöyle bir sorun var.
Çrash işlemi gerçekleştikten sonra bile space tuşuna basınca thrusterlar çalışıyor, bunun olmasını istemiyorum. Çarpma gerçekleşince controlleri devre dışı bırakmam lazım.
Bundan dolayı çarpma işlemi sonrasında gerçekleşecek olayları bir metod altında toplayıp switch'in default kısmında o metodu cagıracagım. Burada yapacağım şey ise 
Movement scriptine giderek orada Enable haline getirdiğim thrust ve rotation'ı disable durumuna sokmam. 

- Burada roketin parent objecti olan Player Rocket'e iki tane script bağlı. Bunlardan biri Movement diğeri ise CollisionHandler. Player Rocket'in inspectorı altında
bu iki script'in yanında checked işaretleri belli. Burada şunu yapabiliyorum, CollisionHandler scriptinden vereceğim bir komutla Movement scriptini devre dışı bırakabiliyorum, yani bir 
süre unchecked duruma sokabiliyorum.

- Script de olsa Movement bir component ve buna erişebilmek için GetComponent'ı kullanacağım. CollisionHandler içinde yazacağım satır 
 GetComponent<Movement>().enabled = false; olacak. Bu şekilde Movement scriptine erişerek scripti bir süreliğine devre dışı bırakıyorum

void StartCrashSequence()
    {
        GetComponent<Movement>().enabled = false;
        Invoke("ReloadLevel", 2f);
    }

- Code dosyanı düzenlerken izlemen gereken bir layout var. Önce değişken tanımlamaların SerializeField olacak ya da olmayacak şekilde sonra Cacheler yani caching variables
Rigidbody rb; gibi, en sonunda da State , private instances (member) variables mesela bool isAlive; 

- Artık burada yapacağımız şey Multiple Auido Clip eklemek. Yani çarpma durumunda çarpma sesi eklenecek ama arkada thrusterlar çalışıyor ya da landing pad'e ulaşınca
başarılı olduğunu gösterir sound'ı çalmasını isteyeceğiz.

- Burada unity dökümantasyonunu inceleyince AudioSource.PlayOneShot metodunu göreceksin. Bu metod içine 2 parametre alacak (AudioClip clip, float VolumeScale = 1.0F )

- Burada SerializeField tipinde bir mainEngine değişkeni oluşturuyoruz ancak bunu Movement scriptinde yapıyoruz.

- 
using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 1000;
    [SerializeField] float rotationStrength = 100f;
    [SerializeField] AudioClip mainEngine;
    AudioSource audioSource;
    Rigidbody rb;
    void Start()
    {
        audioSource = GetComponent<AudioSource>();
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
            if (!audioSource.isPlaying)
            {   
                audioSource.PlayOneShot(mainEngine);
            }
        }
        else
        {
            audioSource.Stop();
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            // transform.Rotate(Vector3.back * rotationStrength * Time.fixedDeltaTime); 
            // transform.Rotate(-Vector3.forward);
            ApplyRotation(-rotationStrength);     
        }
        else if (rotationInput < 0)
        {
            ApplyRotation(rotationStrength);
        }
    }
    private void ApplyRotation(float rotationThisFrame)
    {
        rb.freezeRotation = true;
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
        rb.freezeRotation = false;
    }
}
    
"[SerializeField] AudioClip mainEngine;" değişkeni tanımladıktan sonra "audioSource.PlayOneShot(mainEngine);" satırıyla düzenlemeyi yapıyoruz. Sonrasında
unity arayüzüne gelince Player Rocket objectinin inspectorundaki Movement scriptinin altında Main Engine değişkenini görüyorsun ve yanında senden bir ses dosyasına assign etmeni
bekliyor.

-Şimdi de çarpışma durumunda ve landing pad'e erişme durumunda hangi soundları kontrol edeceğiz. Bundan dolayı önce CollisionHandler scriptine geliyoruz, sonrasında orada SerializeField olacak 
şekilde AudioClip tipinde 2 değişken tanımlıyoruz. Biri success durumu diğeri de çarpışma durumu için. Sonrasında da AudioSource audioSource olacak şekilde bir değişken tanımlıyoruz. Sonrasında
Start metodunu tanımlayıp, audioSource değişkenini cacheliyoruz: audioSource = GetComponent<AudioSource>();

-
using UnityEngine;
using UnityEngine.SceneManagement;

public class CollisionHandler : MonoBehaviour
{
    [SerializeField] float levelLoadDelay = 2f;
    [SerializeField] AudioClip success;
    [SerializeField] AudioClip crash;
    AudioSource audioSource;
    void Start()
    {
        audioSource = GetComponent<AudioSource>();
    }
    void OnCollisionEnter(Collision collision)
    {
        switch (collision.gameObject.tag)
        {
            case "Friendly":
                Debug.Log("BEGIN");
                break;
            case "Finish":
                Debug.Log("FINISH");
                StartSuccessSequence();
                break;
            case "Fuel":
                Debug.Log("FUEL");
                break;
            default:
                StartCrashSequence();
                break;

        }
    }
    void StartSuccessSequence()
    {
        audioSource.PlayOneShot(success);
        GetComponent<Movement>().enabled = false;
        Invoke("LoadNextLevel", levelLoadDelay);
    }
    void StartCrashSequence()
    {
        audioSource.PlayOneShot(crash);
        GetComponent<Movement>().enabled = false;
        Invoke("ReloadLevel", levelLoadDelay);
    }
    void LoadNextLevel()
    {
        int nextScene = SceneManager.GetActiveScene().buildIndex + 1;
        if (nextScene == SceneManager.sceneCountInBuildSettings)
        {
            nextScene = 0;
         }
        SceneManager.LoadScene(nextScene);
    }
    void ReloadLevel()
    {
        int currentScene = SceneManager.GetActiveScene().buildIndex;
        SceneManager.LoadScene(currentScene);
    }
}



[SerializeField] AudioClip success;
[SerializeField] AudioClip crash;
AudioSource audioSource;

Burada değişkenleri tanımladık ve altta crash ve nextlevel'a geçeceği durumlarda da audioSource.PlayOneShot(success); ya da parametre olarak crash yazdık. Şimdi de 
unity arayüzüne girerek sağda inspector altında o serializefield değişkenlerine o sound dosyalarını atayacağız. Bu değişkenleri CollisionHandler scriptinde yazdığımız için
sağda inspector altında ses dosyalarının atamalarını CollisionHandler scripti altında göreceğiz.

- Burada şu durumla karşılaşıyorsun: Ses dosyalarının düzgün calıstıgı scene'den sonraki scene geçtiğinde orada ses dosyaları çalışmıyor. Bunun sebebi de bir scene'de yaptığın bu 
değişken tanımlamalarının, ses dosyaları atamalarını prefab'in tamamına uygulaman lazım. Yoksa yaptığın değişiklik sadece o scene için geçerli oluyor. Burada suna dikkat et
böyle geneli kapsayan ayarlamalar için bir scenei kullan ve sonra prefab kısmından apply all'a tıkla. Bir scene'de bir değişiklik yapıp diğer scene'de başka bir değişiklik yaparsan işi
içinden çıkılamaz hale getirirsin.

- Şimdi state durumunu bool tipinde bir değişken kullanarak ayarlayacağız. Ancak bundan önce unity'nin default skybox colorını ayarlayacağız. Ayarlanmamış hali açık mavi, yani gökyüzüne baktığında
gördüğün mavi. Bunun ayarlaması için önce Assets folderına gelerek bir Material folderı oluşturuyoruz. Sonrasında folder içine gelip sağ tıklayıp create->rendering->material kısmından bir material 
oluşturuyoruz. Material'ın inspector'ı altında "Shader" kısmında "Universal Render Pipeline…" yazısının olduğu yere tıklayarak oradan "Skybox" sonrasında da "Procedural"'ı seçiyoruz. Bize direkt olarak
unity'nin gökyüzü görüntüsünü inspector altında veriyor.

- Material'ın inspector altındaki "Sky Tint" kısmından rengi seçip sonrasında sürükleyip oyun içine bırakarak gökyüzü rengini değiştiriyoruz. Burada yapacağın diğer bir ayar da "atmosphere thickness"
bu ayarı artırman gökyüzünü yeşilin koyu tonlarına doğru götürtecek. Ground'ı siyah yapıp Exposure ayarını en sola çekersen oyuna eklediğin objectlerin dışında her şey tamamen siyah olacak.

- Solda Directional Light intensity'sini artırarak oyundaki gölgelerin karanlık değerlerini ve cisimlerin üzerine ışık düşünce gösterdikleri parlaklığı ayarlayabilirsin

- Burada yapacağımız bir ayarlama da şu olacak, eğer roket bir yere çarptıktan sonra landing pad'ine değerse yani oraya çarparsa hem crash hem de success sesi çıkıyor, bunu engellemek için
burada bool tipinde bir değişken ile state kontrolü yapacağız. Bu değişkeni CollisionHandler içinde tutacağız.

- bool isControllable = true; değişkenini CollisionHandler içinde tanımladık. Neden true tanımladık, çünkü sadece crash ve success durumlarında control edilememe durumunu istiyoruz.

- 
using UnityEngine;
using UnityEngine.SceneManagement;

public class CollisionHandler : MonoBehaviour
{
    [SerializeField] float levelLoadDelay = 2f;
    [SerializeField] AudioClip success;
    [SerializeField] AudioClip crash;
    AudioSource audioSource;

    bool isControllable = true;
    void Start()
    {
        audioSource = GetComponent<AudioSource>();
    }
    void OnCollisionEnter(Collision collision)
    {
        if (!isControllable) { return; }

        switch (collision.gameObject.tag)
        {
            case "Friendly":
                Debug.Log("BEGIN");
                break;
            case "Finish":
                Debug.Log("FINISH");
                StartSuccessSequence();
                break;
            case "Fuel":
                Debug.Log("FUEL");
                break;
            default:
                StartCrashSequence();
                break;

        }
    }
    void StartSuccessSequence()
    {
        isControllable = false;
        audioSource.Stop();
        audioSource.PlayOneShot(success);
        GetComponent<Movement>().enabled = false;
        Invoke("LoadNextLevel", levelLoadDelay);
    }
    void StartCrashSequence()
    {
        isControllable = false;
        audioSource.Stop();
        audioSource.PlayOneShot(crash);
        GetComponent<Movement>().enabled = false;
        Invoke("ReloadLevel", levelLoadDelay);
    }
    void LoadNextLevel()
    {
        int nextScene = SceneManager.GetActiveScene().buildIndex + 1;
        if (nextScene == SceneManager.sceneCountInBuildSettings)
        {
            nextScene = 0;
         }
        SceneManager.LoadScene(nextScene);
    }
    void ReloadLevel()
    {
        int currentScene = SceneManager.GetActiveScene().buildIndex;
        SceneManager.LoadScene(currentScene);
    }
}

- Şimdi de particle'lara giriyoruz. Roketin altından duman çıkartma ya da particle atmak gibi bir olayı yapacağız.

- Particle System Component'i iki parçadan oluşuyor, emmitter ve particle. Particle System is a Component added to a Game Object. We use modules for controlling behavior. Burada
dikkat et, Each particle is NOT a GAME OBJECT.

- Şimdi over scene'i içinde Hierarchy içinde sağa tıklayıp effect->particle system yolunu izleyerek oyuna particle system game objecti ekliyorum. Ya da şunu da yapabilirsin,
empty bir game object ekleyip add component kısmından particle system ekleyebilirsin. Tam olarak aynı şey değil ama kullanım amacına göre aynı işi yapabilir.

- Particle System componentinde aşağıda "Renderer" kısmı altında Material var, burada bir renk atarsak sisteme verilen particleların rengi değişecek, aynı şekilde atılan particlelar sanki
Mouse ile seçilmiş gibi küçük karelerin içinde çıkıyor. Bunu engellemek için yukarıda Scene yazısının hemen altındaki View option, orientation, toggle gibi ayarlamaların olduğu yerde
etrafı birbirine dik iki eksenle çevrilmiş yuvarlak simgenin "Toggle visibility of all Gizmos in the scene view" sağına tıklayıp oradaki "Selection Outline" kısmını kapatıyoruz, böylece her bir particle'ın
etrafındaki kareler gidiyor

- Particle System'deki duration kısmını kaç saniye particle yaymasını istiyorsak yazacağız ve sonrasında altındaki Loop kısmını da unchecked hale getireceğiz. Aşağı taraflarda 
Rate Over Time var, o da ayarladığın sürede kaç particle emit edeceğinin göstergesi. Aynı şekilde aşağıda Shape kısmından da particleların hangi geometrik şekilde emit edeceğini 
gösteriyor.

- Tasarlanmış güzel bir particle buldum, bunu kendi projemde kullanacağım. Assets altına gelip Particle folder'ı oluşturup, indirdiğim ve unitypackage uzantılı dosyayı buraya atıyorum.
Bunlar arasında Roket jet particleları da var, explosion particleları da var.

- Burada yapacağımız şey şu, eğer Roket bir yere çarparsa, o çarptığı pointi bul ve tam oradan bu particleları çarpma durumlarına uygun olarak yayılmasını sağla. Landing pad'e inince de bir çarpma durumu var
orada da yeşil renki success particlelarını yay. Burada önce amaç carpısma noktasını bulmak ya da diğer bir yol şu, carpısma olduğunda roket neredeyse particleları yaymak için o konumu kullan.

- Burada önce Roketin parentı olan Player Rocket'in prefab kısmını aç, yani Hierarchy içindeyken sağa doğru yönlenmiş oka tıkla ve saydam beyaz bir ekranda objecti göreceksin. Orada Parent objectin altına
yani childı olarak hem success particle'ını hem de crash particle'ını ekle. Bu particleları ekledikten sonra player rocket'te dikkate edeceğin şey particlelar loop içinde olmayacak, ve PlayOnAwake kısmı 
unchecked halinde olacak.

- Prefab ekranı hala açıkken, eklediğimiz Player Rocket altına eklediğimiz particle'ların sağda inspector altındaki Transform'da position değerlerini 0,0,0 olarak güncelliyoruz. Bu şu demek, parent 
object roket olduğundan dolayı bu particlelar tam olarak roketin üzerinde olacak. Burada kullanılan positionlar, relative positionlar.

- Unity arayüzündeki ayarlamalarımız bitti, şimdi de kodda durumu ayarlamamız gerekecek. CollisionHandler scriptine gelerek SerializeField olacak şekilde ve ParticleSystem tipinde bir değişken 
tanımlıyorum. Sonrasında da Unity arayüzünde parent olan roket objectine tıklayıp SerializeField olarak tanımladığım değişkenleri particlelara eşliyorum ancak burada şuna çok dikkat et. Bu particle
dosyalarını Assets içindeki folderdan sakın alma, çünkü oradaki particle objectlerinin scene içinde nerede konumlandığını bilmiyorsun. Senin alacağın particle objectler, Hierarchy altındaki Parent olan
Player Rocket'in altına attığın ve konumlarını 0,0,0 yaparak tam olarak roketin üstünde olmasını sağladığın particle objectler olacak. Onları sürükle bırakla, inspector altındaki SerializeField içindeki
o değişkenleri Parent objectin altındaki particlelarla bağla.

- 
    [SerializeField] ParticleSystem successParticles;
    [SerializeField] ParticleSystem crashParticles;
Bu şekilde CollisionHandler içinde tanımladıktan sonra, bu particleların calısacagı conditionlara gelip successParticle.Play(); komutunu yazacağız.
En sonunda da Prefab kısmına gelip "Apply All" diyeceğiz.

- Şimdiki aşamada yapacağımız şey, roketin arkasında bıraktığı particleları eklemek. Gerçek hayatta bu roketin arkasında gördüğün büyük bir ateş topuna tekabül ediyor. Ancak burada
left thruster, right thruster ve main enginenın thrust'ını halledeceğiz.

- Import ettiğim package içinde sadece Side Thruster adında bir tane particle var. Bunu left ve right olarak ben ayarlayacağım. 

- Over scene'i içindeyken Rocket Jet Particles objectini Player Rocket objecti onun parent'ı olacak şekilde Player Rocket altına ekliyorum. Bundan sonra Rocket Jet Propulsion koordinatlarını
0,0,0 yapınca da tam olarak roketin üzerinde olacak. Çünkü bu durumda parent'ına göreceli olarak konumlanıyor yani parent'ını origin olarak tanıyor.

- Koordinatlarını ayarladıktan sonra jet particle'ın çıkış şeklini beğenmediysen Shape kısmından şekil ayarlaması yapabilirsin ya da shape kısmına hiç bulaşmadan 
Radius ayarlayarak daha geniş bir propulsion alanı elde edebilirsin. Rate over Time kısmınıdaki değeri yükselterek particle yoğunluğunu halledebilirsin.

- Rocket jet particles inspectorunda Radius, rate over time gibi kısımları ayarladıktan sonra Hierarchy içindeki rocket jet propulsion objectinin kenarında yeşil bir artı görünecek. Bu işaret
yapılan değişiklikleri prefab'e eklemediğini gösteriyor. Prefab'e eklemeden önce Side thruster particles'ı Player Rocket objectinin childı olacak şekilde hierarchy içinde konumlandırıyorum sonrasında 
bunu sağdaki iticinin altında konumlandırdıktan sonra adını Right Thruster Particles olarak değiştiriyorum.Sonrasında bir daha Side Thruster Particle ekleyerek bunu da rotate ettirerek soldaki iticinin 
altına konumlandırıyorum. Bunları yaptıktan sonra 3 particle objectinde de Rocket Jet Particles, Left Thruster Particles ve Right Thruster Particles kısmında yeşil artılar çıktı. Parent Objecte
yani Player Rocket'e gelip Prefab kısmından Apply All'a tıklayarak yaptığım değişiklikleri prefab'e ekliyorum

- Artık kod kısmında ayarlamaları yapacağız, Movement scripte gelerek 3ü de serializefield ve ParticleSystem tipinde olacak şekilde mainEngineParticles, Left ve Right thrusterları tanımlıyorum. SerializeField 
olarak tanımlamamın nedeni, oyun içinde bunların atamalarını yapıp daha modüler bir kontrole sahip olmak. Bunları tanımladıktan sonra Unity arayüzüne gelerek bunları component altındaki scriptin içinde değişkenleri
bağladık. Burada tekrardan suna dikkat et, engine thrusterları bağlarken Hierarchy içindeki objectlerle bağla. Folder içinden bağladıklarının Scene içindeki konumlarını bilmiyorsun. Bundan dolayı konumlarını ayarladığın
asıl objectlerle bağlaman daha doğru olur.

- Movement scripti içinde asıl engine'ın thrust particlelarını ProcessThrust metodu içinde yazacağım ancak side thrust işini rotation metodu içinde yazacağım.
 
   private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
            if (!audioSource.isPlaying)
            {
                audioSource.PlayOneShot(mainEngineSFX);
            }
            mainEngineParticles.Play();
        }
        else
        {
            audioSource.Stop();
            mainEngineParticles.Stop();
        }
    }


private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            // transform.Rotate(Vector3.back * rotationStrength * Time.fixedDeltaTime); 
            // transform.Rotate(-Vector3.forward);
            ApplyRotation(-rotationStrength);
            leftThrusterParticles.Play();
        }
        else if (rotationInput < 0)
        {
            ApplyRotation(rotationStrength);
            rightThrusterParticles.Play();
        }
        else
        {
            rightThrusterParticles.Stop();
            leftThrusterParticles.Stop();
        }
    }

Burada particlesları durdurmayı unutma yoksa bir kere basınca sürekli particle atıyor. "rightThrusterParticles.Stop();" ve "rightThrusterParticles.Play();" statementları sayesinde 
particle emission kontrollerini yapıyoruz.

- Movement.cs

using UnityEngine;
using UnityEngine.InputSystem;
public class Movement : MonoBehaviour
{
    [SerializeField] InputAction thrust;
    [SerializeField] InputAction rotation;
    [SerializeField] int thrustStrength = 1000;
    [SerializeField] float rotationStrength = 100f;
    [SerializeField] AudioClip mainEngineSFX;
    [SerializeField] ParticleSystem mainEngineParticles;
    [SerializeField] ParticleSystem leftThrusterParticles;
    [SerializeField] ParticleSystem rightThrusterParticles;
    AudioSource audioSource;
    Rigidbody rb;
    void Start()
    {
        audioSource = GetComponent<AudioSource>();
        rb = GetComponent<Rigidbody>();
    }
    void OnEnable()
    {
        thrust.Enable();
        rotation.Enable();
    }
    private void FixedUpdate()
    {
        ProcessThrust();
        ProcessRotation();
    }
    private void ProcessThrust()
    {
        if (thrust.IsPressed())
        {
            rb.AddRelativeForce(Vector3.up * thrustStrength * Time.fixedDeltaTime);
            if (!audioSource.isPlaying)
            {
                audioSource.PlayOneShot(mainEngineSFX);
            }
            if (!mainEngineParticles.isPlaying)
            {
                mainEngineParticles.Play();
            }
        }
        else
        {
            audioSource.Stop();
            mainEngineParticles.Stop();
        }
    }
    private void ProcessRotation()
    {
        float rotationInput = rotation.ReadValue<float>();
        if (rotationInput > 0)
        {
            // transform.Rotate(Vector3.back * rotationStrength * Time.fixedDeltaTime); 
            // transform.Rotate(-Vector3.forward);
            ApplyRotation(-rotationStrength);
            if (!leftThrusterParticles.isPlaying)
            {
                leftThrusterParticles.Play();
            }
            
        }
        else if (rotationInput < 0)
        {
            ApplyRotation(rotationStrength);
            if (!rightThrusterParticles.isPlaying)
            {
                rightThrusterParticles.Play();
            }
        }
        else
        {
            rightThrusterParticles.Stop();
            leftThrusterParticles.Stop();
        }
    }
    private void ApplyRotation(float rotationThisFrame)
    {
        rb.freezeRotation = true;
        transform.Rotate(Vector3.forward * rotationThisFrame * Time.fixedDeltaTime);
        rb.freezeRotation = false;
    }
}
    
En son haliyle Movement.cs

- 

